import{gY as D,aE as v,f as c,gZ as d,g_ as g,dh as y}from"./index-DPJiPkbh.js";import{O as $}from"./quat-B_RTSvGc.js";import{t as h,n as I}from"./vec3f32-Cw9Q6TO_.js";import{u as M,c as m,i as O,f as w}from"./PointCloudWorkerUtil-CIv_MlLN.js";import{O as _}from"./orientedBoundingBox-BABDZfWD.js";import"./PointCloudUniqueValueRenderer-C9upHfI5.js";import"./I3SBinaryReader-CDLgGPje.js";import"./VertexAttribute-BnAa5VW0.js";import"./mat3-CakTilsz.js";import"./spatialReferenceEllipsoidUtils-MJ9Uj9G-.js";import"./computeTranslationToOriginAndRotation-DJULrcwj.js";import"./Attribute-B-NAci_J.js";class S{transform(t){const r=this._transform(t),a=[r.points.buffer,r.rgb.buffer];r.pointIdFilterMap!=null&&a.push(r.pointIdFilterMap.buffer);for(const e of r.attributes)"buffer"in e.values&&D(e.values.buffer)&&e.values.buffer!==r.rgb.buffer&&a.push(e.values.buffer);return Promise.resolve({result:r,transferList:a})}_transform(t){const r=M(t.schema,t.geometryBuffer);let a=r.length/3,e=null;const l=new Array,b=m(t.primaryAttributeData,r,a);t.primaryAttributeData!=null&&b&&l.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:b});const o=m(t.modulationAttributeData,r,a);t.modulationAttributeData!=null&&o&&l.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:o});let n=O(t.rendererInfo,b,o,a);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const i=t.filterAttributesData.filter(v).map(s=>{const u=m(s,r,a),p={attributeInfo:s.attributeInfo,values:u};return l.push(p),p});e=new Uint32Array(a),a=w(r,n,e,t.filterInfo,i)}for(const i of t.userAttributesData){const s=m(i,r,a);l.push({attributeInfo:i.attributeInfo,values:s})}3*a<n.length&&(n=new Uint8Array(n.buffer.slice(0,3*a))),this._applyElevationOffsetInPlace(r,a,t.elevationOffset);const f=this._transformCoordinates(r,a,_.fromData(t.obbData),c.fromJSON(t.inSR),c.fromJSON(t.outSR));return{obbData:t.obbData,points:f,rgb:n,attributes:l,pointIdFilterMap:e}}_transformCoordinates(t,r,a,e,l){if(!d(t,e,0,t,l,0,r))throw new Error("Can't reproject");const b=h(a.center),o=I(),n=I(),f=h(a.halfSize);$(A,a.quaternion);const i=new Float32Array(3*r);for(let s=0;s<r;s++){let u=3*s;o[0]=t[u]-b[0],o[1]=t[u+1]-b[1],o[2]=t[u+2]-b[2],g(n,o,A),f[0]=Math.max(f[0],Math.abs(n[0])),f[1]=Math.max(f[1],Math.abs(n[1])),f[2]=Math.max(f[2],Math.abs(n[2])),i[u++]=o[0],i[u++]=o[1],i[u]=o[2]}return a.halfSize=f,i}_applyElevationOffsetInPlace(t,r,a){if(a!==0)for(let e=0;e<r;e++)t[3*e+2]+=a}}const A=y();function L(){return new S}export{L as default};
