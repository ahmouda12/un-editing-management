import{cG as A,a5 as C,cH as j,ba as G,aC as H,cI as K,cJ as S,cK as q,cL as W,aE as P,cM as k,bO as v,cN as B,bJ as D,cO as F,cP as Q,ad as V}from"./index-B252NKV0.js";import{w as o}from"./drawSurfaces-qxkfYhbx.js";function d(r,a){const s=new V({x:r[0],y:r[1],spatialReference:a});return r.length>2&&(s.z=r[2]),s}function Z(r,a){return new A({points:r,spatialReference:a})}function _(r,a,s){const e=new C({paths:r,spatialReference:a});return s&&j(e),e}function I(r,a,s,e=!0){const l=G(r);l.forEach(n=>{const i=n[0],c=n[n.length-1];H(i,c)&&n.length!==1||n.push(n[0])});let t=new K({rings:l,spatialReference:a});return t.rings.forEach(n=>{S(n)||n.reverse()}),s&&j(t),e&&t.isSelfIntersecting&&q(a)&&(t=W(t)),t}function aa(r,a,s){const e=a.mapToLocalMultiple(r),l=[],t={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y},i=Math.round(n.x-t.x),c=Math.round(n.y-t.y),y=Math.max(Math.abs(i),Math.abs(c));if(s){const u={x:t.x+y,y:t.y+y},f={x:t.x-y,y:t.y-y};l.push(o(u.x,f.y),o(f.x,f.y),o(f.x,u.y),o(u.x,u.y))}else{const u={x:i>0?t.x+y:t.x-y,y:c>0?t.y+y:t.y-y};l.push(o(t.x,t.y),o(u.x,t.y),o(u.x,u.y),o(t.x,u.y))}return J(I([l.map(u=>a.localToMap(u)).filter(P)],a.spatialReference,a.doUnnormalization,!0),l,a)}function ta(r,a,s){let e=a.mapToLocalMultiple(r);if(e.length===1){const c=e[0];e=[o(c.x-48,c.y+48),o(c.x+48,c.y-48),o(c.x+48,c.y-48),o(c.x-48,c.y+48)]}const l=[],t={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y};if(s){const i=Math.round(n.x-t.x),c=Math.round(n.y-t.y);l.push(o(t.x-i,t.y-c),o(n.x,t.y-c),o(n.x,n.y),o(t.x-i,n.y))}else l.push(o(t.x,t.y),o(n.x,t.y),o(n.x,n.y),o(t.x,n.y));return J(I([l.map(i=>a.localToMap(i)).filter(P)],a.spatialReference,a.doUnnormalization,!0),l,a)}function J(r,a,s){const e=w(a[3],a[2],s),l=w(a[1],a[2],s),t=w(a[0],a[1],s),n=w(a[0],a[3],s);return{geometry:r,midpoints:e!=null&&l!=null&&t!=null&&n!=null?{top:e,right:l,bottom:t,left:n}:null}}function w(r,a,s){T[0]=r.x,T[1]=r.y,T[2]=0,g[0]=a.x,g[1]=a.y,g[2]=0,k(T,T,g,.5),z.x=T[0],z.y=g[1],z.z=g[2];const e=s.localToMap(z);return e!=null?d(e,s.spatialReference):null}const z=o(0,0,0),T=v(),g=v();function na(r,a,s,e){const l=a.mapToLocalMultiple(r);let t=null,n=null;if(s)t=l[0],n=l[1];else{const x=l[0],p=l[1],R=Math.round(p.x-x.x),b=Math.round(p.y-x.y),h=Math.max(Math.abs(R),Math.abs(b));t=o(R>0?x.x+h/2:x.x-h/2,b>0?x.y+h/2:x.y-h/2),n=o(Math.abs(R)>Math.abs(b)?t.x-h/2:t.x,Math.abs(R)>Math.abs(b)?t.y:t.y-h/2)}const i=a.localToMap(t),c=a.localToMap(n);if(i==null||c==null)return null;a.doUnnormalization&&B([[i,c]],a.spatialReference);const y=d(i,a.spatialReference),u=d(c,a.spatialReference),f=D(a.spatialReference);let M=0;if(q(a.spatialReference))M=f*F(y,u,null);else{const x=t.x-n.x,p=t.y-n.y;M=f*Math.sqrt(x*x+p*p)*(e||1)}const $=new Q({center:y,radius:M,radiusUnit:"meters",spatialReference:a.spatialReference});return{geometry:I($.rings,$.spatialReference,!1),center:y,edge:u}}function ea(r,a,s){const e=a.mapToLocalMultiple(r),l=e[0],t=e[1],n=Math.round(t.x-l.x),i=Math.round(t.y-l.y),c=o(s?l.x:l.x+n/2,s?l.y:l.y+i/2),y=s?n:n/2,u=s?i:i/2,f=60,M=[],$=2*Math.PI/f;function x(m){const N=Math.cos(m),O=Math.sin(m);return o(y*N+c.x,u*O+c.y)}for(let m=0;m<f;m++)M.push(x(m*$));M.push(M[0]);const{spatialReference:p,doUnnormalization:R}=a,b=I([M.map(m=>a.localToMap(m)).filter(P)],p,R,!1),h=a.localToMap(x(Math.PI/2)),U=a.localToMap(x(0)),L=a.localToMap(x(-Math.PI/2)),E=a.localToMap(x(Math.PI));return{geometry:b,midpoints:h!=null&&U!=null&&L!=null&&E!=null?{top:d(h,p),right:d(U,p),bottom:d(L,p),left:d(E,p)}:null}}export{na as L,_ as R,aa as T,ta as b,Z as d,I as j,ea as v};
