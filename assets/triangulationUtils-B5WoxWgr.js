import{i as x}from"./earcut-gCDAS0gj.js";import{c0 as P,ct as F,ec as W,cw as h,bJ as X,bK as Z,kh as v,bL as H,a6 as Y,cI as j,cJ as C}from"./index-B252NKV0.js";import{a as k,e as B,t as N}from"./DoubleArray-DydFqj4b.js";import{A as G,t as R}from"./Indices-BSZ2vHzt.js";import{e as M}from"./deduplicate-aiEVsYi-.js";import{t as b}from"./Attribute-B-NAci_J.js";import{e as _}from"./ContentObject-BZXFh7BC.js";import{I as T}from"./Geometry-Ba4xjwln.js";import{e as A}from"./VertexAttribute-BnAa5VW0.js";function J(t,n,r,o){const e=(s=>!Array.isArray(s[0]))(n)?(s,i)=>n[3*s+i]:(s,i)=>n[s][i],a=o?X(o)/Z(o):1;return v(t,(s,i)=>H(s,e(i,0)*a,e(i,1)*a,e(i,2)),r)}function U(t,n,r){const o=J(S,t,n,r)?F(S):[0,0,1];return Math.abs(o[2])>Math.cos(W(80))?h.Z:Math.abs(o[1])>Math.abs(o[0])?h.Y:h.X}const S=P();function at(t,n,r){const o=U(t,(n.length>0?n[0]:t.length/3)-1,r);if(o!==h.Z){t=t.slice();for(let e=0;e<t.length;e+=3)t[e+o]=t[e+2]}return x(t,n,3)}function st(t){const n=[[A.POSITION,new b(t.attributeData.position,t.indices,3,!0)]],r=G(t.indices.length);return t.attributeData.colorFeature!=null?n.push([A.COLORFEATUREATTRIBUTE,new b([t.attributeData.colorFeature],r,1,!0)]):t.attributeData.color&&n.push([A.COLOR,new b(t.attributeData.color,r,4,!0)]),t.attributeData.uvMapSpace&&n.push([A.UVMAPSPACE,new b(t.attributeData.uvMapSpace,t.indices,4,!0)]),t.attributeData.boundingRect&&n.push([A.BOUNDINGRECT,new b(t.attributeData.boundingRect,t.indices,9,!0)]),new T(t.material,n,t.mapPositions,_.Mesh,t.attributeData.objectAndLayerIdColor)}function ct(t,n=null){const r=[[A.POSITION,new b(t.attributeData.position,t.indices,3,!0)],[A.UV0,new b(t.attributeData.uv0,t.indices,2,!0)]];return new T(t.material,r,t.mapPositions,_.Mesh,n)}function lt(t){switch(t.type){case"extent":if(t instanceof Y)return j.fromExtent(t);break;case"polygon":return t}return null}class ut{constructor(n,r,o){this.renderData=n,this.layerUid=r,this.graphicUid=o,this.outGeometries=new Array}}function ht(t){const n=K(t.rings,t.hasZ,D.CCW_IS_HOLE,t.spatialReference),r=new Array;let o=0,e=0;for(const i of n.polygons){const c=i.count,f=i.index,d=k(n.position,3*f,3*c),I=i.holeIndices.map(u=>u-f),m=R(x(d,I,3));r.push({position:d,faces:m}),o+=d.length,e+=m.length}const a=V(r,o,e),s=Array.isArray(a.position)?M(a.position,3,{originalIndices:a.faces}):M(a.position.buffer,6,{originalIndices:a.faces});return a.position=B(new Float64Array(s.buffer)),a.faces=s.indices,a}function V(t,n,r){if(t.length===1)return t[0];const o=N(n),e=new Array(r);let a=0,s=0,i=0;for(const c of t){for(let f=0;f<c.position.length;f++)o[a++]=c.position[f];for(const f of c.faces)e[s++]=f+i;i=a/3}return{position:o,faces:R(e)}}function K(t,n,r,o){const e=t.length,a=new Array(e),s=new Array(e),i=new Array(e);let c=0,f=0,d=0,I=0;for(let p=0;p<e;++p)I+=t[p].length;const m=N(3*I);let u=0;for(let p=e-1;p>=0;p--){const l=t[p],E=r===D.CCW_IS_HOLE&&q(l,n,o);if(E&&e!==1)a[c++]=l;else{let L=l.length;for(let g=0;g<c;++g)L+=a[g].length;const w={index:u,pathLengths:new Array(c+1),count:L,holeIndices:new Array(c)};w.pathLengths[0]=l.length,l.length>0&&(i[d++]={index:u,count:l.length}),u=E?O(l,l.length-1,-1,m,u,l.length,n):O(l,0,1,m,u,l.length,n);for(let g=0;g<c;++g){const y=a[g];w.holeIndices[g]=u,w.pathLengths[g+1]=y.length,y.length>0&&(i[d++]={index:u,count:y.length}),u=O(y,0,1,m,u,y.length,n)}c=0,w.count>0&&(s[f++]=w)}}for(let p=0;p<c;++p){const l=a[p];l.length>0&&(i[d++]={index:u,count:l.length}),u=O(l,0,1,m,u,l.length,n)}return s.length=f,i.length=d,{position:m,polygons:s,outlines:i}}function O(t,n,r,o,e,a,s){e*=3;for(let i=0;i<a;++i){const c=t[n];o[e++]=c[0],o[e++]=c[1],o[e++]=s?c[2]:0,n+=r}return e/3}function q(t,n,r){if(n){const o=t.length-1,e=U(t,o,r);if(e===h.X)return!C(t,h.Y,h.Z);if(e===h.Y)return!C(t,h.X,h.Z)}return!C(t,h.X,h.Y)}var D;(function(t){t[t.NONE=0]="NONE",t[t.CCW_IS_HOLE=1]="CCW_IS_HOLE"})(D||(D={}));export{lt as A,ct as D,ut as O,st as d,ht as f,K as g,D as u,at as w};
