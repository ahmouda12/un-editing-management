import{c0 as T,c1 as _,c2 as F,c3 as x,c4 as on,c5 as u,c6 as rn,c7 as z,c8 as f,c9 as o,ca as p,bL as P,cb as cn,cc as un,cd as gn,ce as m,cf as bn,cg as ln,ch as fn,ci as h,cj as pn,ck as dn,cl as D,cm as $n,cn as U,co as v,cp as O,cq as hn,cr as mn,cs as $,ct as M,cu as In,cv as Pn,cw as V,cx as G,cy as J,bO as N,cz as W,aU as vn}from"./index-DPJiPkbh.js";import{v as Nn,A as L,M as Mn}from"./lineSegment-BXFQuctu.js";const E=()=>vn.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class wn{constructor(){this.plane=T(),this.origin=N(),this.basis1=N(),this.basis2=N()}}const Tn=wn;function I(n=en){return{plane:T(n.plane),origin:x(n.origin),basis1:x(n.basis1),basis2:x(n.basis2)}}function An(n,i,s){const a=kn.get();return a.origin=n,a.basis1=i,a.basis2=s,a.plane=on(0,0,0,0),y(a),a}function A(n,i=I()){return X(n.origin,n.basis1,n.basis2,i)}function yn(n,i){u(i.origin,n.origin),u(i.basis1,n.basis1),u(i.basis2,n.basis2),rn(i.plane,n.plane)}function X(n,i,s,a=I()){return u(a.origin,n),u(a.basis1,i),u(a.basis2,s),y(a),qn(a,"fromValues()"),a}function y(n){z(n.basis2,n.basis1,n.origin,n.plane)}function Z(n,i,s){n!==s&&A(n,s);const a=f(o.get(),l(n),i);return p(s.origin,s.origin,a),s.plane[3]-=i,s}function Sn(n,i,s){return H(i,s),Z(s,B(n,n.origin),s),s}function H(n,i=I()){const s=(n[2]-n[0])/2,a=(n[3]-n[1])/2;return P(i.origin,n[0]+s,n[1]+a,0),P(i.basis1,s,0,0),P(i.basis2,0,a,0),cn(0,0,1,0,i.plane),i}function Y(n,i,s){return!!un(n.plane,i,s)&&an(n,s)}function _n(n,i,s){if(Y(n,i,s))return s;const a=K(n,i,o.get());return p(s,i.origin,f(o.get(),i.direction,gn(i.origin,a)/m(i.direction))),s}function K(n,i,s){const a=w.get();tn(n,i,a,w.get());let t=Number.POSITIVE_INFINITY;for(const e of C){const r=k(n,e,S.get()),g=o.get();if(bn(a,r,g)){const c=ln(o.get(),i.origin,g),b=Math.abs(fn(h(i.direction,c)));b<t&&(t=b,u(s,g))}}return t===Number.POSITIVE_INFINITY?Q(n,i,s):s}function Q(n,i,s){if(Y(n,i,s))return s;const a=w.get(),t=w.get();tn(n,i,a,t);let e=Number.POSITIVE_INFINITY;for(const r of C){const g=k(n,r,S.get()),c=o.get();if(pn(a,g,c)){const b=dn(i,c);if(!D(t,c))continue;b<e&&(e=b,u(s,c))}}return q(n,i.origin)<e&&nn(n,i.origin,s),s}function nn(n,i,s){const a=$n(n.plane,i,o.get()),t=L(R(n,n.basis1),a,-1,1,o.get()),e=L(R(n,n.basis2),a,-1,1,o.get());return U(s,p(o.get(),t,e),n.origin),s}function sn(n,i,s){const{origin:a,basis1:t,basis2:e}=n,r=U(o.get(),i,a),g=v(t,r),c=v(e,r),b=v(l(n),r);return P(s,g,c,b)}function q(n,i){const s=sn(n,i,o.get()),{basis1:a,basis2:t}=n,e=m(a),r=m(t),g=Math.max(Math.abs(s[0])-e,0),c=Math.max(Math.abs(s[1])-r,0),b=s[2];return g*g+c*c+b*b}function xn(n,i){return Math.sqrt(q(n,i))}function On(n,i){let s=Number.NEGATIVE_INFINITY;for(const a of C){const t=k(n,a,S.get()),e=Mn(t,i);e>s&&(s=e)}return Math.sqrt(s)}function Vn(n,i){return D(n.plane,i)&&an(n,i)}function En(n,i,s,a){return Yn(n,s,a)}function B(n,i){const s=-n.plane[3];return v(l(n),i)-s}function jn(n,i,s,a){const t=B(n,i),e=f(Bn,l(n),s-t);return p(a,i,e),a}function zn(n,i){return O(n.basis1,i.basis1)&&O(n.basis2,i.basis2)&&O(n.origin,i.origin)}function Fn(n,i,s){return n!==s&&A(n,s),hn(d,i),mn(d,d),$(s.basis1,n.basis1,d),$(s.basis2,n.basis2,d),$(M(s.plane),M(n.plane),d),$(s.origin,n.origin,i),In(s.plane,s.plane,s.origin),s}function Un(n,i,s,a){return n!==a&&A(n,a),Pn(j,i,s),$(a.basis1,n.basis1,j),$(a.basis2,n.basis2,j),y(a),a}function l(n){return M(n.plane)}function Yn(n,i,s){switch(i){case V.X:u(s,n.basis1),G(s,s);break;case V.Y:u(s,n.basis2),G(s,s);break;case V.Z:u(s,l(n))}return s}function an(n,i){const s=U(o.get(),i,n.origin),a=J(n.basis1),t=J(n.basis2),e=h(n.basis1,s),r=h(n.basis2,s);return-e-a<0&&e-a<0&&-r-t<0&&r-t<0}function R(n,i){const s=S.get();return u(s.origin,n.origin),u(s.vector,i),s}function k(n,i,s){const{basis1:a,basis2:t,origin:e}=n,r=f(o.get(),a,i.origin[0]),g=f(o.get(),t,i.origin[1]);p(s.origin,r,g),p(s.origin,s.origin,e);const c=f(o.get(),a,i.direction[0]),b=f(o.get(),t,i.direction[1]);return f(s.vector,p(c,c,b),2),s}function qn(n,i){Math.abs(h(n.basis1,n.basis2)/(m(n.basis1)*m(n.basis2)))>1e-6&&E().warn(i,"Provided basis vectors are not perpendicular"),Math.abs(h(n.basis1,l(n)))>1e-6&&E().warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-h(l(n),n.origin)-n.plane[3])>1e-6&&E().warn(i,"Plane offset is not consistent with plane origin")}function tn(n,i,s,a){const t=l(n);z(t,i.direction,i.origin,s),z(M(s),t,i.origin,a)}const en={plane:T(),origin:_(0,0,0),basis1:_(1,0,0),basis2:_(0,1,0)},w=new F(T),S=new F(Nn),Bn=N(),kn=new F(()=>I()),C=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=W(),j=W(),Jn=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:Tn,altitudeAt:B,axisAt:En,closestPoint:Q,closestPointOnSilhouette:K,copy:A,copyWithoutVerify:yn,create:I,distance:xn,distance2:q,distanceToSilhouette:On,elevate:Z,equals:zn,extrusionContainsPoint:Vn,fromAABoundingRect:H,fromValues:X,intersectRay:Y,intersectRayClosestSilhouette:_n,normal:l,projectPoint:nn,projectPointLocal:sn,rotate:Un,setAltitudeAt:jn,setExtent:Sn,transform:Fn,up:en,updateUnboundedPlane:y,wrap:An},Symbol.toStringTag,{value:"Module"}));export{H as $,Tn as G,X as H,y as J,I as W,A as Z,Jn as _,xn as a,l as d,Fn as l,Un as m,zn as p,Y as s,Vn as u};
