import{y as Q}from"./mat3-DPPMYMhB.js";import{bO as _,el as N,ce as p,bL as T,dm as u,em as c,en as U,cz as O,cq as W,cr as D,di as X,dZ as E,eo as Y,cs as F,ca as ss}from"./index-B252NKV0.js";import{O as ts,L as rs}from"./orientedBoundingBox-B61nPEal.js";class ps{constructor(){this._transform=O(),this._transformInverse=new b({value:this._transform},W,O),this._transformInverseTranspose=new b(this._transformInverse,D,O),this._transformTranspose=new b({value:this._transform},D,O),this._transformInverseRotation=new b({value:this._transform},Q,X)}_invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(s){E(this._transform,s)}multiplyTransform(s){Y(this._transform,this._transform,s)}set(s){E(this._transform,s),this._invalidateLazyTransforms()}setAndInvalidateLazyTransforms(s,r){this.setTransformMatrix(s),this.multiplyTransform(r),this._invalidateLazyTransforms()}}class b{constructor(s,r,e){this._original=s,this._update=r,this._dirty=!0,this._transform=e()}invalidate(){this._dirty=!0}get value(){return this._dirty&&(this._update(this._transform,this._original.value),this._dirty=!1),this._transform}}class es{constructor(s=0){this.offset=s,this.tmpVertex=_()}applyToVertex(s,r,e){const a=T(I,s,r,e),o=ss(P,a,this.localOrigin),i=this.offset/p(o);return u(this.tmpVertex,a,o,i),this.tmpVertex}applyToAabb(s){const r=is,e=os,a=hs;for(let t=0;t<3;++t)r[t]=s[0+t]+this.localOrigin[t],e[t]=s[3+t]+this.localOrigin[t],a[t]=r[t];const o=this.applyToVertex(r[0],r[1],r[2]);for(let t=0;t<3;++t)s[t]=o[t],s[t+3]=o[t];const i=t=>{const n=this.applyToVertex(t[0],t[1],t[2]);for(let l=0;l<3;++l)s[l]=Math.min(s[l],n[l]),s[l+3]=Math.max(s[l+3],n[l])};for(let t=1;t<8;++t){for(let n=0;n<3;++n)a[n]=t&1<<n?e[n]:r[n];i(a)}let f=0;for(let t=0;t<3;++t)r[t]*e[t]<0&&(f|=1<<t);if(f!==0&&f!==7){for(let t=0;t<8;++t)if(!(f&t)){for(let n=0;n<3;++n)a[n]=f&1<<n?0:t&1<<n?r[n]:e[n];i(a)}}for(let t=0;t<3;++t)s[t]-=this.localOrigin[t],s[t+3]-=this.localOrigin[t];return s}}class ns{constructor(s=0){this.componentLocalOriginLength=0,this._totalOffset=0,this._offset=0,this._tmpVertex=_(),this._tmpMbs=N(),this._tmpObb=new ts,this._resetOffset(s)}_resetOffset(s){this._offset=s,this._totalOffset=s}set offset(s){this._resetOffset(s)}get offset(){return this._offset}set componentOffset(s){this._totalOffset=this._offset+s}set localOrigin(s){this.componentLocalOriginLength=p(s)}applyToVertex(s,r,e){const a=T(I,s,r,e),o=T(P,s,r,e+this.componentLocalOriginLength),i=this._totalOffset/p(o);return u(this._tmpVertex,a,o,i),this._tmpVertex}applyToAabb(s){const r=this.componentLocalOriginLength,e=s[0],a=s[1],o=s[2]+r,i=s[3],f=s[4],t=s[5]+r,n=Math.abs(e),l=Math.abs(a),y=Math.abs(o),x=Math.abs(i),d=Math.abs(f),L=Math.abs(t),w=.5*(1+Math.sign(e*i))*Math.min(n,x),$=.5*(1+Math.sign(a*f))*Math.min(l,d),q=.5*(1+Math.sign(o*t))*Math.min(y,L),z=Math.max(n,x),A=Math.max(l,d),R=Math.max(y,L),j=Math.sqrt(w*w+$*$+q*q),B=Math.sign(n+e),Z=Math.sign(l+a),G=Math.sign(y+o),S=Math.sign(x+i),k=Math.sign(d+f),C=Math.sign(L+t),m=this._totalOffset;if(j<m)return s[0]-=(1-B)*m,s[1]-=(1-Z)*m,s[2]-=(1-G)*m,s[3]+=S*m,s[4]+=k*m,s[5]+=C*m,s;const M=m/Math.sqrt(z*z+A*A+R*R),g=m/j,v=g-M,V=-v;return s[0]+=e*(B*V+g),s[1]+=a*(Z*V+g),s[2]+=o*(G*V+g),s[3]+=i*(S*v+M),s[4]+=f*(k*v+M),s[5]+=t*(C*v+M),s}applyToMbs(s){const r=p(c(s)),e=this._totalOffset/r;return u(c(this._tmpMbs),c(s),c(s),e),this._tmpMbs[3]=s[3]+s[3]*this._totalOffset/r,this._tmpMbs}applyToObb(s){return rs(s,this._totalOffset,this._totalOffset,U.Global,this._tmpObb),this._tmpObb}}class as{constructor(s=0){this.offset=s,this.sphere=N(),this.tmpVertex=_()}applyToVertex(s,r,e){const a=this.objectTransform.transform,o=T(I,s,r,e),i=F(o,o,a),f=this.offset/p(i);u(i,i,i,f);const t=this.objectTransform.inverse;return F(this.tmpVertex,i,t),this.tmpVertex}applyToMinMax(s,r){const e=this.offset/p(s);u(s,s,s,e);const a=this.offset/p(r);u(r,r,r,a)}applyToAabb(s){const r=this.offset/Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);s[0]+=s[0]*r,s[1]+=s[1]*r,s[2]+=s[2]*r;const e=this.offset/Math.sqrt(s[3]*s[3]+s[4]*s[4]+s[5]*s[5]);return s[3]+=s[3]*e,s[4]+=s[4]*e,s[5]+=s[5]*e,s}applyToBoundingSphere(s){const r=p(c(s)),e=this.offset/r;return u(c(this.sphere),c(s),c(s),e),this.sphere[3]=s[3]+s[3]*this.offset/r,this.sphere}}const H=new as;function cs(h){return h!=null?(H.offset=h,H):null}const J=new ns;function _s(h){return h!=null?(J.offset=h,J):null}const K=new es;function us(h){return h!=null?(K.offset=h,K):null}const Ms="terrain",I=_(),P=_(),is=_(),os=_(),hs=_();export{us as I,_s as L,cs as d,ps as v,Ms as w};
