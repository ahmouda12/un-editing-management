const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/ColorMaterial.glsl-9YKbkIUs.js","assets/index-B252NKV0.js","assets/index-HngaTkmj.css","assets/mat3-DPPMYMhB.js","assets/BufferView-DithrMUX.js","assets/IntegerPassUniform-BV9MAEur.js","assets/enums-DSseSvdG.js","assets/Texture-BT-WYJiR.js","assets/BindType-BmZEZMMh.js","assets/interfaces-CGza0uBR.js","assets/Util-DsJryf9x.js","assets/VertexAttribute-BnAa5VW0.js","assets/basicInterfaces-DngWxyLO.js","assets/ShaderTechniqueConfiguration-Ba2Oo7i0.js","assets/doublePrecisionUtils-B0owpBza.js","assets/Material-5cwIpifF.js","assets/ContentObject-BZXFh7BC.js","assets/requestImageUtils-DzTga_rS.js","assets/InterleavedLayout-DjPFAyuB.js","assets/types-D0PSWh4d.js","assets/VertexColor.glsl-D4WHfTL4.js","assets/OrderIndependentTransparency-Dar7ikM6.js","assets/hydratedFeatures-BRhOD9YG.js","assets/floatRGBA-0vmpOgzj.js"])))=>i.map(i=>d[i]);
import{n_ as Ge,dZ as it,cz as W,eo as Be,cM as Ka,em as br,w6 as Xs,cs as ye,cd as jr,c1 as st,el as Ks,qV as eo,bL as Q,ca as le,cp as St,c5 as X,bO as E,eX as ea,ep as Ae,mk as to,eP as ta,c$ as yr,w7 as Ui,fR as ro,bz as Ar,aJ as Dt,ce as Jt,gN as wr,pI as Hi,cY as Mt,cx as re,c8 as se,cn as ae,w8 as Dr,m5 as Tt,m6 as Rt,ee as Ve,x as m,y as b,ab as ra,dP as io,dT as pi,mW as so,d7 as Gi,de as Wi,dd as Vr,d4 as or,w9 as ao,n$ as oo,cq as kt,cr as ia,e7 as Ri,wa as no,wb as Bi,ib as ki,ci as Lt,kn as qi,km as lo,co,e2 as ho,ek as Ht,f$ as Gt,en as Oi,df as Le,cg as uo,aU as zr,wc as sa,B as tr,nO as Ke,eN as Yt,f7 as bi,oL as po,d5 as fi,_ as Ai,c0 as rr,dn as nr,k3 as Me,ct as Zi,mv as fo,gZ as mi,b$ as k,iN as mo,ob as Qi,dR as go,ch as _o,jM as gi,jN as qe,jL as xt,mV as zt,jI as Ji,bT as Ct,p3 as ne,nK as vo,jK as Yi,di as yo,wd as wo,we as Xi,ga as Ki,nG as Wt,sT as xo,eI as Co,cR as Ur,eT as es,g1 as So,je as Hr,wf as To,dV as Ro,c3 as ts,e4 as Oo,cc as bo,er as Ao,wg as Do,gn as Mo,E as Eo,m4 as $o,wh as Io}from"./index-B252NKV0.js";import{c as Po,h as Re,O as aa,t as Gr}from"./Material-5cwIpifF.js";import{c as M,R as Mr,O as Lo,D as oa,F as Di,s as ke,G as Ft,b as Z,Q as Mi,x as et,S as Wr,T as na,U as la,V as Fo,W as No,X as jo,Y as ct,o as Ei,H as ca,g as da,Z as rs,_ as zo,$ as Vo,u as Uo,a0 as $i,v as xr,N as Ho,a1 as Go,a2 as Wo,a3 as Bo,d as ko,a4 as qo,C as Zo,a as Qo,P as Jo,f as Yo,y as Br,r as Ii,i as Pi,a5 as Xo,j as is,k as ss,l as Ko,h as Li,a6 as as,a7 as en,a8 as tn,a9 as rn,aa as sn,A as ie,ab as os,ac as an,B as on,ad as nn,ae as kr,af as ln,ag as cn,ah as dn,ai as hn,aj as un,I as pn,ak as fn,p as mn,al as gn,t as De,am as ns}from"./IntegerPassUniform-BV9MAEur.js";import{o as w,n as ha}from"./interfaces-CGza0uBR.js";import{b as _n,d as ls,y as cs}from"./axisAngleDegrees-C5xDLED1.js";import{p as dt,i as vn}from"./weather-BLxro0E8.js";import{I as yn}from"./RenderState-DaVlEYWY.js";import{a as ua}from"./BindType-BmZEZMMh.js";import{t as Fi}from"./NestedMap-DgiGbX8E.js";import{t as pa,r as P}from"./ShaderTechniqueConfiguration-Ba2Oo7i0.js";import{H as wn,N as xn,L as Cn,j as lr}from"./frustum-VM_sBTPR.js";import{s as pe,m as Sn,u as Tn,c as ht,f as cr,l as Rn}from"./Util-DsJryf9x.js";import{t as j}from"./Attribute-B-NAci_J.js";import{r as fa,e as Nt}from"./ContentObject-BZXFh7BC.js";import{r as ds,n as hs,a as us,I as we}from"./Geometry-Ba4xjwln.js";import{t as ps,i as On,a as bn}from"./basicInterfaces-DngWxyLO.js";import{E as An,e as v}from"./VertexAttribute-BnAa5VW0.js";import{W as Dn}from"./Octree-C_vy2cBS.js";import{v as ma,M as Mn,b as qr,d as En}from"./lineSegment-BMYSACYW.js";import{H as $n}from"./InterleavedLayout-DjPFAyuB.js";import{o as Ue,S as tt,d as Zr,A as In,l as Pn,a as Ln,E as Fn,_ as Et,e as Nn,g as jn,s as zn}from"./OrderIndependentTransparency-Dar7ikM6.js";import{o as ga}from"./floatRGBA-0vmpOgzj.js";import{G as _a,D as Er,E as fs,M as Vn,_ as $r,F as Un,R as Ot,L as Hn}from"./enums-DSseSvdG.js";import{e as Ni,m as Xt}from"./Texture-BT-WYJiR.js";import{i as Gn}from"./Intersector-DFmhN7LU.js";import{t as ms,G as Wn,i as Bn,c as kn,f as qn,b as dr}from"./ElevationProvider-Z72XcWTz.js";import{r as Zn}from"./glUtil-DS73TAjp.js";import{o as Qn}from"./VertexArrayObject-adc8SYn-.js";import{h as Jn}from"./BufferObject-DdM-Y0w0.js";import{I as Yn,C as Xn}from"./Scheduler-D2EdV-K_.js";import{r as J,n as Oe,t as gs}from"./vec3f32-Cw9Q6TO_.js";import{t as Kn}from"./DoubleArray-DydFqj4b.js";import{A as va,l as el}from"./Indices-BSZ2vHzt.js";import{R as tl}from"./computeTranslationToOriginAndRotation-BwxvMbbc.js";import{u as rl}from"./hydratedFeatures-BRhOD9YG.js";var qt,Ir,_i;(function(t){t[t.RasterImage=0]="RasterImage",t[t.Features=1]="Features"})(qt||(qt={})),function(t){t[t.MapLayer=0]="MapLayer",t[t.ViewLayer=1]="ViewLayer",t[t.Outline=2]="Outline",t[t.SnappingHint=3]="SnappingHint"}(Ir||(Ir={})),function(t){t[t.WithRasterImage=0]="WithRasterImage",t[t.WithoutRasterImage=1]="WithoutRasterImage"}(_i||(_i={}));var Pr,Ie;(function(t){t[t.ADD=0]="ADD",t[t.UPDATE=1]="UPDATE",t[t.REMOVE=2]="REMOVE"})(Pr||(Pr={})),function(t){t[t.NONE=0]="NONE",t[t.VISIBILITY=1]="VISIBILITY",t[t.GEOMETRY=2]="GEOMETRY",t[t.TRANSFORMATION=4]="TRANSFORMATION",t[t.HIGHLIGHT=8]="HIGHLIGHT",t[t.OCCLUDEE=16]="OCCLUDEE"}(Ie||(Ie={}));var Kt;(function(t){t[t.ASYNC=0]="ASYNC",t[t.SYNC=1]="SYNC"})(Kt||(Kt={}));let il=class extends fa{get geometries(){return this._geometries}get transformation(){return this._transformation??Ge}set transformation(e){this._transformation=it(this._transformation??W(),e),this._invalidateBoundingVolume(),this._emit("transformationChanged",this)}get shaderTransformation(){return this._shaderTransformation}set shaderTransformation(e){this._shaderTransformation=e?it(this._shaderTransformation??W(),e):null,this._invalidateBoundingVolume(),this._emit("shaderTransformationChanged",this)}get effectiveTransformation(){return this.shaderTransformation??this.transformation}constructor(e={}){super(),this.type=Nt.Object,this._shaderTransformation=null,this._parentLayer=null,this._visible=!0,this.castShadow=e.castShadow??!0,this.usesVerticalDistanceToGround=e.usesVerticalDistanceToGround??!1,this.graphicUid=e.graphicUid,this.layerUid=e.layerUid,e.isElevationSource&&(this.lastValidElevationBB=new ya),this._geometries=e.geometries?Array.from(e.geometries):new Array}dispose(){this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(e){pe(this._parentLayer==null||e==null,"Object3D can only be added to a single Layer"),this._parentLayer=e}addGeometry(e){e.visible=this._visible,this._geometries.push(e),this._emit("geometryAdded",{object:this,geometry:e}),this._invalidateBoundingVolume()}removeGeometry(e){const r=this._geometries.splice(e,1)[0];r&&(this._emit("geometryRemoved",{object:this,geometry:r}),this._invalidateBoundingVolume())}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttributeUpdated(e,r,i=!1){this._emit("attributesChanged",{object:this,geometry:e,attribute:r,sync:i}),An(r)&&this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(e){if(this._visible!==e){this._visible=e;for(const r of this._geometries)r.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const e=new ds(ps.MaskOccludee);for(const r of this._geometries)r.occludees=hs(r.occludees,e);return this._emit("occlusionChanged",this),e}removeOcclude(e){for(const r of this._geometries)r.occludees=us(r.occludees,e);this._emit("occlusionChanged",this)}highlight(){const e=new ds(ps.Highlight);for(const r of this._geometries)r.highlights=hs(r.highlights,e);return this._emit("highlightChanged",this),e}removeHighlight(e){for(const r of this._geometries)r.highlights=us(r.highlights,e);this._emit("highlightChanged",this)}getCombinedStaticTransformation(e,r){return Be(r,this.transformation,e.transformation)}getCombinedShaderTransformation(e,r=W()){return Be(r,this.effectiveTransformation,e.transformation)}get boundingVolumeWorldSpace(){return this._bvWorldSpace||(this._bvWorldSpace=this._bvWorldSpace||new _s,this._validateBoundingVolume(this._bvWorldSpace,Zt.WorldSpace)),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._bvObjectSpace||(this._bvObjectSpace=this._bvObjectSpace||new _s,this._validateBoundingVolume(this._bvObjectSpace,Zt.ObjectSpace)),this._bvObjectSpace}_validateBoundingVolume(e,r){const i=r===Zt.ObjectSpace;for(const s of this._geometries){const a=s.boundingInfo;a&&sl(a,e,i?s.transformation:this.getCombinedShaderTransformation(s))}Ka(br(e.bounds),e.min,e.max,.5);for(const s of this._geometries){const a=s.boundingInfo;if(a==null)continue;const o=i?s.transformation:this.getCombinedShaderTransformation(s),n=Xs(o);ye(vs,a.center,o);const c=jr(vs,br(e.bounds)),l=a.radius*n;e.bounds[3]=Math.max(e.bounds[3],c+l)}}_invalidateBoundingVolume(){var r;const e=(r=this._bvWorldSpace)==null?void 0:r.bounds;this._bvObjectSpace=this._bvWorldSpace=void 0,this._parentLayer&&e&&this._parentLayer.notifyObjectBBChanged(this,e)}_emit(e,r){this._parentLayer&&this._parentLayer.events.emit(e,r)}get test(){const e=this;return{hasGeometry:r=>e._geometries.includes(r),getGeometryIndex:r=>e._geometries.indexOf(r)}}},ya=class{constructor(){this.min=st(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=st(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}},_s=class extends ya{constructor(){super(...arguments),this.bounds=Ks()}};function sl(t,e,r){const i=t.bbMin,s=t.bbMax;if(eo(r)){const a=Q(al,r[12],r[13],r[14]);le(_e,i,a),le(Se,s,a);for(let o=0;o<3;++o)e.min[o]=Math.min(e.min[o],_e[o]),e.max[o]=Math.max(e.max[o],Se[o])}else if(ye(_e,i,r),St(i,s))for(let a=0;a<3;++a)e.min[a]=Math.min(e.min[a],_e[a]),e.max[a]=Math.max(e.max[a],_e[a]);else{ye(Se,s,r);for(let a=0;a<3;++a)e.min[a]=Math.min(e.min[a],_e[a],Se[a]),e.max[a]=Math.max(e.max[a],_e[a],Se[a]);for(let a=0;a<3;++a){X(_e,i),X(Se,s),_e[a]=s[a],Se[a]=i[a],ye(_e,_e,r),ye(Se,Se,r);for(let o=0;o<3;++o)e.min[o]=Math.min(e.min[o],_e[o],Se[o]),e.max[o]=Math.max(e.max[o],_e[o],Se[o])}}}const al=E(),_e=E(),Se=E(),vs=E();var Zt;(function(t){t[t.WorldSpace=0]="WorldSpace",t[t.ObjectSpace=1]="ObjectSpace"})(Zt||(Zt={}));const ol=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","transformationChanged","shaderTransformationChanged","visibilityChanged","occlusionChanged","highlightChanged","geometryAdded","geometryRemoved","attributesChanged"];let nl=class extends fa{get objects(){return this._objects}constructor(e,r,i=""){super(),this.stage=e,this.apiLayerUid=i,this.type=Nt.Layer,this.events=new ea,this.visible=!0,this.pickable=!0,this.sliceable=!1,this._objects=new Ae,this._objectsAdded=new Ae,this._handles=new to,this.apiLayerUid=i,this.visible=(r==null?void 0:r.visible)??!0,this.pickable=(r==null?void 0:r.pickable)??!0,this.updatePolicy=(r==null?void 0:r.updatePolicy)??Kt.ASYNC,this._disableOctree=(r==null?void 0:r.disableOctree)??!1,e.add(this);for(const s of ol)this._handles.add(this.events.on(s,a=>e.handleEvent(s,a)))}destroy(){this._handles.size&&(this._handles.destroy(),this.stage.remove(this),this.invalidateSpatialQueryAccelerator())}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),this._octree!=null&&this._objectsAdded.push(e)}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),this._octree!=null&&(this._objectsAdded.removeUnordered(e)||this._octree.remove([e])))}addMany(e){this._objects.pushArray(e);for(const r of e)r.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),this._octree!=null&&this._objectsAdded.pushArray(e)}removeMany(e){const r=new Array;if(this._objects.removeUnorderedMany(e,e.length,r),r.length!==0){for(const i of r)i.parentLayer=null;if(this.events.emit("layerObjectsRemoved",{layer:this,objects:r}),this._octree!=null){for(let i=0;i<r.length;)this._objectsAdded.removeUnordered(r[i])?(r[i]=r[r.length-1],r.length-=1):++i;this._octree.remove(r)}}}sync(){this.updatePolicy!==Kt.SYNC&&this.stage.syncLayer(this.id)}notifyObjectBBChanged(e,r){this._octree==null||this._objectsAdded.includes(e)||this._octree.update(e,r)}getSpatialQueryAccelerator(){return this._octree==null&&this._objects.length>50&&!this._disableOctree?(this._octree=new Dn(e=>e.boundingVolumeWorldSpace.bounds),this._octree.add(this._objects.data,this._objects.length)):this._octree!=null&&this._objectsAdded.length>0&&(this._octree.add(this._objectsAdded.data,this._objectsAdded.length),this._objectsAdded.clear()),this._octree}invalidateSpatialQueryAccelerator(){this._octree=ta(this._octree),this._objectsAdded.clear()}};function nh(t){return t!=null&&t.type===Nt.Layer}let ll=class extends Qn{};var be,ys,ws,xs;(function(t){t[t.INNER=0]="INNER",t[t.OUTER=1]="OUTER"})(be||(be={})),function(t){t[t.REGULAR=0]="REGULAR",t[t.HAS_NORTH_POLE=1]="HAS_NORTH_POLE",t[t.HAS_SOUTH_POLE=2]="HAS_SOUTH_POLE",t[t.HAS_BOTH_POLES=3]="HAS_BOTH_POLES"}(ys||(ys={})),function(t){t[t.OFF=0]="OFF",t[t.ON=1]="ON"}(ws||(ws={})),function(t){t[t.FADING=0]="FADING",t[t.IMMEDIATE=1]="IMMEDIATE",t[t.UNFADED=2]="UNFADED"}(xs||(xs={}));let cl=class{constructor(e,r){this.vec3=e,this.id=r}};function vi(t,e,r,i){return new cl(st(t,e,r),i)}let Cs=class{constructor(){this._extent=yr(),this.resolution=0,this.renderLocalOrigin=vi(0,0,0,"O"),this.pixelRatio=1,this.mapUnitsPerPixel=1,this.canvasGeometries=new dl}get extent(){return this._extent}setupGeometryViewsCyclical(e){this.setupGeometryViewsDirect();const r=.001*e.range;if(this._extent[0]-r<=e.min){const i=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Ui(this._extent,e.range,0,i)}if(this._extent[2]+r>=e.max){const i=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Ui(this._extent,-e.range,0,i)}}setupGeometryViewsDirect(){this.canvasGeometries.numViews=1,ro(this.canvasGeometries.extents[0],this._extent)}hasSomeSizedView(){for(let e=0;e<this.canvasGeometries.numViews;e++){const r=this.canvasGeometries.extents[e];if(r[0]!==r[2]&&r[1]!==r[3])return!0}return!1}},dl=class{constructor(){this.extents=[yr(),yr(),yr()],this.numViews=0}};var Y;(function(t){t[t.Color=0]="Color",t[t.ColorNoRasterImage=1]="ColorNoRasterImage",t[t.Highlight=2]="Highlight",t[t.WaterNormal=3]="WaterNormal",t[t.Occluded=4]="Occluded",t[t.ObjectAndLayerIdColor=5]="ObjectAndLayerIdColor"})(Y||(Y={}));let hl=class{constructor(e,r,i){this._fbos=e,this._format=r,this._name=i}get valid(){var e;return((e=this._handle)==null?void 0:e.getTexture())!=null}dispose(){this._handle=Ar(this._handle)}get texture(){var e;return(e=this._handle)==null?void 0:e.getTexture()}bind(e,r,i){var s,a,o;this._handle&&this._handle.fbo.width===r&&this._handle.fbo.height===i||((s=this._handle)==null||s.release(),this._handle=this._fbos.acquire(r,i,this._name,this._format)),e.unbindTexture((a=this._handle)==null?void 0:a.fbo.colorTexture),e.bindFramebuffer((o=this._handle)==null?void 0:o.fbo)}generateMipMap(){var e,r,i,s,a;(i=(r=(e=this._handle)==null?void 0:e.getTexture())==null?void 0:r.descriptor)!=null&&i.hasMipmap&&((a=(s=this._handle)==null?void 0:s.getTexture())==null||a.generateMipmap())}},ut=class{constructor(e,r,i,s,a=Mr.RGBA_MIPMAP){this.output=i,this.content=s,this.fbo=new hl(e,a,r)}get valid(){return this.fbo.valid}},ul=class{constructor(e){this.targets=[new ut(e,"overlay color",M.Color,Y.Color),new ut(e,"overlay IM color",M.Color,Y.ColorNoRasterImage),new ut(e,"overlay highlight",M.Highlight,Y.Highlight,Mr.RGBA4),new ut(e,"overlay water",M.Normal,Y.WaterNormal),new ut(e,"overlay occluded",M.Color,Y.Occluded)],Dt("enable-feature:objectAndLayerId-rendering")&&this.targets.push(new ut(e,"overlay oid",M.ObjectAndLayerIdColor,Y.ObjectAndLayerIdColor))}getTexture(e){var r;return(r=this.targets[e])==null?void 0:r.fbo.texture}dispose(){for(const e of this.targets)e.fbo.dispose()}computeValidity(){return this.targets.reduce((e,r,i)=>r.valid?e|=1<<i:e,0)}},ji=class extends Lo{constructor(){super(...arguments),this.slicePlaneLocalOrigin=E(),this.origin=this.slicePlaneLocalOrigin,this.modelTransformation=null}};var We;(function(t){t[t.Material=0]="Material",t[t.ShadowMap=1]="ShadowMap",t[t.Highlight=2]="Highlight"})(We||(We={}));let gh=class extends ji{constructor(){super(...arguments),this.identifier=We.Material,this.output=M.Color,this.transparent=!1}},vh=class extends ji{constructor(){super(...arguments),this.identifier=We.ShadowMap}},wh=class extends ji{constructor(){super(...arguments),this.identifier=We.Highlight}};function Ch(t){t.fragment.code.add(w`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)}function pl(t){t.fragment.code.add(w`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)}function fl(t){t.fragment.code.add(w`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)}function ml(t,e){const r=t.fragment;r.include(oa),r.uniforms.add(new Di("nearFar",(i,s)=>s.camera.nearFar)),r.uniforms.add(new ke("depthMap",(i,s)=>{var a;return(a=s.linearDepth)==null?void 0:a.getTexture()})),r.uniforms.add(new Ft("proj",(i,s)=>s.camera.projectionMatrix)),r.uniforms.add(new Z("invResolutionHeight",(i,s)=>1/s.camera.height)),r.uniforms.add(new Ft("reprojectionMatrix",(i,s)=>s.ssr.reprojectionMatrix)),r.code.add(w`
  vec2 reprojectionCoordinate(vec3 projectionCoordinate)
  {
    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
    reprojectedCoord.xy /= reprojectedCoord.w;
    return reprojectedCoord.xy * 0.5 + 0.5;
  }

  const int maxSteps = ${e.highStepCount?"150":"75"};

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
        return vec3(P, depth);
      }

      // continue with ray marching
      P = clamp(P + dP, vec2(0.0), vec2(0.999));
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)}var rt,Lr;function Sh(t){return(t==null?void 0:t.cubeMap)!=null}function gl(t){return t!=null&&!t.running}(function(t){t[t.RENDERING=0]="RENDERING",t[t.FADING=1]="FADING",t[t.FINISHED=2]="FINISHED"})(rt||(rt={})),function(t){t[t.RG=0]="RG",t[t.BA=1]="BA"}(Lr||(Lr={}));let _l=class{constructor(){this.readChannels=Lr.RG,this.renderingStage=rt.FINISHED,this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=E(),this.parallax=new Ss,this.parallaxNew=new Ss,this.pointOnGround=E(),this.fadeMode=G.HIDE,this.fadeFactor=0,this.opacity=0}updateParallax(e){const r=this.parallax,i=Jt(e.eye);if(r.radiusCurvatureCorrectionFactor=.84*Math.sqrt(Math.max(i*i-wr.radius*wr.radius,0))/i,ls(Ts,r.anchorPointClouds,pt),Hi(r.transform,Ge,pt[3],cs(pt)),this.fadeMode===G.CROSS_FADE){const s=this.parallaxNew;ls(Ts,s.anchorPointClouds,pt),Hi(s.transform,Ge,pt[3],cs(pt))}}updateFading(e,r,i,s){this.isFading&&this._advanceFading(i,s),this._evaluateFading(e,r,i)}_evaluateFading(e,r,i){const s=e.relativeElevation,a=this._calculateDistanceToAnchorPoint(e);if((s>1.7*dt||s<-dt||a>Cl)&&this.opacity>0)this._setFade(G.HIDE,i);else if(!this.isFading){if((s>dt||s<-.35*dt||a>xl)&&this.opacity>0)this._setFade(G.FADE_OUT,i);else if(s<=dt&&s>=-.35*dt&&r===yn.IDLE&&gl(this.data)){if(this.opacity===0)return void this._setFade(G.FADE_IN,i);(a>wl||this.renderingStage===rt.FADING)&&this._setFade(G.CROSS_FADE,i)}}}_advanceFading(e,r){this._switchReadChannels(),this._updateAnchorPoint(),this._advanceFadingFactorAndOpacity(e,r)}_advanceFadingFactorAndOpacity(e,r){if(this.fadeFactor<1)return this.fadeFactor=r?Mt((e-this.startTime)/(yl*r),0,1):1,this.fadeMode===G.FADE_OUT&&(this.opacity=1-this.fadeFactor),this.fadeMode===G.FADE_IN&&(this.opacity=this.fadeFactor),void(this.fadeMode===G.CROSS_FADE&&(this.opacity=1));this.fadeFactor=0,this.fadeMode===G.FADE_OUT&&(this.opacity=0),this.fadeMode===G.FADE_IN&&(this.opacity=1),this.fadeMode===G.CROSS_FADE&&(this.opacity=1),this.fadeMode=G.NONE}_switchReadChannels(){const e=this.fadeMode===G.CROSS_FADE&&this.fadeFactor===1,r=this.fadeMode===G.FADE_IN&&this.fadeFactor===0;this.renderingStage===rt.FADING&&(e||r)&&(this.readChannels=1-this.readChannels,this.renderingStage=rt.FINISHED)}_calculateDistanceToAnchorPoint(e){return re(this.pointOnGround,e.eye),se(this.pointOnGround,this.pointOnGround,wr.radius),Jt(ae(vl,this.parallax.anchorPointClouds,this.pointOnGround))}_updateAnchorPoint(){this.fadeMode===G.CROSS_FADE&&(this.fadeFactor===0&&X(this.parallaxNew.anchorPointClouds,this.pointOnGround),this.fadeFactor===1&&X(this.parallax.anchorPointClouds,this.parallaxNew.anchorPointClouds)),this.fadeMode===G.FADE_IN&&this.fadeFactor===0&&X(this.parallax.anchorPointClouds,this.pointOnGround)}_setFade(e,r){switch(e){case G.HIDE:this.opacity=0;break;case G.FADE_OUT:this.opacity=1;break;case G.FADE_IN:this.opacity=0;break;case G.CROSS_FADE:this.opacity=1}this.fadeMode=e,this.fadeFactor=0,this.startTime=r}get isFading(){return this.fadeMode===G.FADE_OUT||this.fadeMode===G.FADE_IN||this.fadeMode===G.CROSS_FADE}};var G;(function(t){t[t.NONE=0]="NONE",t[t.HIDE=1]="HIDE",t[t.FADE_OUT=2]="FADE_OUT",t[t.FADE_IN=3]="FADE_IN",t[t.CROSS_FADE=4]="CROSS_FADE"})(G||(G={}));let Ss=class{constructor(){this.anchorPointClouds=E(),this.radiusCurvatureCorrectionFactor=0,this.transform=W()}};const Ts=st(0,0,1),pt=_n(),vl=E(),yl=1.25,wl=34e3,xl=64e3,Cl=2e5;let Sl=class extends Mi{constructor(e,r){super(e,"samplerCube",ua.Pass,(i,s,a)=>i.bindTexture(e,r(s,a)))}};function Tl(t){const e=t.fragment;e.uniforms.add(new Ft("rotationMatrixClouds",(r,i)=>i.cloudsFade.parallax.transform),new Ft("rotationMatrixCloudsCrossFade",(r,i)=>i.cloudsFade.parallaxNew.transform),new et("anchorPosition",(r,i)=>i.cloudsFade.parallax.anchorPointClouds),new et("anchorPositionCrossFade",(r,i)=>i.cloudsFade.parallaxNew.anchorPointClouds),new Z("cloudsHeight",()=>vn),new Z("radiusCurvatureCorrectionFactor",(r,i)=>i.cloudsFade.parallax.radiusCurvatureCorrectionFactor),new Z("totalFadeInOut",(r,i)=>1-i.cloudsFade.opacity),new Z("crossFadeAnchorFactor",(r,i)=>Mt(i.cloudsFade.fadeFactor,0,1)),new Sl("cubeMap",(r,i)=>{var s,a;return((a=(s=i.cloudsFade.data)==null?void 0:s.cubeMap)==null?void 0:a.colorTexture)??null}),new Wr("crossFade",(r,i)=>i.cloudsFade.fadeMode===G.CROSS_FADE),new Wr("readChannelsRG",(r,i)=>i.cloudsFade.readChannels===Lr.RG),new Wr("fadeTextureChannels",(r,i)=>i.cloudsFade.renderingStage===rt.FADING)),e.constants.add("planetRadius","float",wr.radius),e.code.add(w`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`),e.code.add(w`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`),e.code.add(w`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`),na(e),la(e),e.code.add(w`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`),e.code.add(w`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)
{
vec4 cloudData = texture(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
bool readChannels = readChannelsRG ^^ readOtherChannel;
if (readChannels) {
cloudData = vec4(vec3(cloudData.r), cloudData.g);
} else {
cloudData = vec4(vec3(cloudData.b), cloudData.a);
}
if (length(cloudData) == 0.0) {
return vec4(cloudData.rgb, 1.0);
}
return cloudData;
}`),e.code.add(w`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`),e.code.add(w`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`),e.code.add(w`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`)}function Rl(t,e){t.include(Fo,e),t.include(fl),t.include(pl),e.hasCloudsReflections&&t.include(Tl,e),e.hasScreenSpaceReflections&&t.include(ml,e);const r=t.fragment;r.constants.add("fresnelSky","vec3",[.02,1,15]).add("fresnelMaterial","vec2",[.02,.1]).add("roughness","float",.015).add("foamIntensityExternal","float",1.7).add("ssrIntensity","float",.65).add("ssrHeightFadeStart","float",No).add("ssrHeightFadeEnd","float",jo).add("waterDiffusion","float",.92).add("waterSeaColorMod","float",.8).add("correctionViewingPowerFactor","float",.4).add("skyZenitColor","vec3",[.52,.68,.9]).add("skyColor","vec3",[.67,.79,.9]).add("cloudFresnelModifier","vec2",[1.2,.01]),r.code.add(w`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`),r.uniforms.add(new Z("lightingSpecularStrength",(i,s)=>s.lighting.mainLight.specularStrength),new Z("lightingEnvironmentStrength",(i,s)=>s.lighting.mainLight.environmentStrength)),r.code.add(w`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {
float reflectionHit = 0.0;
float reflectionHitDiffused = 0.0;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}
float correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);
vec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);
vec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),e.hasCloudsReflections&&r.code.add(w`vec4 cloudsColor = renderClouds(reflectedWorld, position);
cloudsColor.a = 1.0 - cloudsColor.a;
cloudsColor = pow(cloudsColor, vec4(GAMMA));
cloudsColor *= clamp(fresnelModifier.y * cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`),e.hasScreenSpaceReflections?(r.uniforms.add(new Ft("view",(i,s)=>s.camera.viewMatrix),new ke("lastFrameColorTexture",(i,s)=>{var a;return(a=s.ssr.lastFrameColor)==null?void 0:a.getTexture()}),new Z("fadeFactorSSR",(i,s)=>s.ssr.fadeFactor)),r.code.add(w`vec3 viewDir = normalize(viewPosition);
vec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = view * vec4(localUp, 0.0);
vec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));
vec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);
reflectionHit = clamp(1.0 - (1.3 * dCoords.y), 0.0, 1.0) * heightMod * fadeFactorSSR;
reflectionHitDiffused = waterDiffusion * reflectionHit;
reflectedColor = linearizeGamma(texture(lastFrameColorTexture, reprojectedCoordinate).xyz) *
reflectionHitDiffused * fresnelModifier.y * ssrIntensity;
}
float seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod * 0.5, reflectionHitDiffused);
vec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor +
reflSea * seaColorMod + specular + foam);`)):r.code.add(w`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),e.hasCloudsReflections?e.hasScreenSpaceReflections?r.code.add(w`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;
}`):r.code.add(w`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;
}`):r.code.add(w`return waterRenderedColor;
}`)}let Rs=class extends Mi{constructor(e,r){super(e,"vec4",ua.Draw,(i,s,a)=>i.setUniform4fv(e,r(s,a)))}};var bt;function Ah(t,e){const{vertex:r,fragment:i}=t;r.uniforms.add(new Rs("overlayTexOffset",(s,a)=>bl(s,a)),new Rs("overlayTexScale",(s,a)=>Al(s,a))),i.constants.add("overlayOpacity","float",1),i.uniforms.add(new ke("ovColorTex",(s,a)=>Ol(s,a))),wa(t,e)}function Dh(t,e){const{vertex:r,fragment:i}=t;r.uniforms.add(new Os("overlayTexOffset"),new Os("overlayTexScale")),i.uniforms.add(new Z("overlayOpacity",s=>s.overlayOpacity),new ke("ovColorTex",(s,a)=>{var o;return(o=a.overlay)==null?void 0:o.getTexture(s.overlayContent)})),wa(t,e)}(function(t){t[t.Disabled=0]="Disabled",t[t.Enabled=1]="Enabled",t[t.EnabledWithWater=2]="EnabledWithWater",t[t.COUNT=3]="COUNT"})(bt||(bt={}));let Os=class extends Mi{constructor(e){super(e,"vec4")}};function wa(t,e){e.pbrMode!==ct.Water&&e.pbrMode!==ct.WaterOnIntegratedMesh&&e.pbrMode!==ct.TerrainWithWater||t.include(Rl,e);const{vertex:r,fragment:i}=t;t.varyings.add("vtcOverlay","vec4"),r.code.add(w`void setOverlayVTC(in vec2 uv) {
vtcOverlay = vec4(uv, uv) * overlayTexScale + overlayTexOffset;
}`),i.code.add(w`bool isValid(vec2 uv, vec2 dxdy) {
return (uv.x >= 0.0 + dxdy.x) && (uv.x <= 1.0 - dxdy.x) && (uv.y >= 0.0 + dxdy.y) && (uv.y <= 1.0 - dxdy.y);
}
vec4 getOverlayColor(sampler2D ov0Tex, vec4 texCoords) {
vec4 color0 = texture(ov0Tex, vec2(texCoords.x * 0.5, texCoords.y));
vec4 color1 = texture(ov0Tex, vec2(texCoords.z * 0.5 + 0.5, texCoords.w));
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`),i.code.add(w`vec4 getCombinedOverlayColor() {
return overlayOpacity * getOverlayColor(ovColorTex, vtcOverlay);
}`),i.code.add(w`vec4 getOverlayColorTexel(vec4 texCoords) {
vec2 texDim =  vec2(textureSize(ovColorTex, 0));
vec4 color0 = texelFetch(ovColorTex, ivec2(vec2(texCoords.x * 0.5, texCoords.y) * texDim), 0);
vec4 color1 = texelFetch(ovColorTex, ivec2(vec2(texCoords.z * 0.5 + 0.5, texCoords.w) * texDim), 0);
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`),e.pbrMode!==ct.Water&&e.pbrMode!==ct.WaterOnIntegratedMesh&&e.pbrMode!==ct.TerrainWithWater||(na(i),la(i),i.code.add(w`vec4 getOverlayWaterColor(vec4 maskInput, vec4 colorInput, vec3 vposEyeDir,
float shadow, vec3 localUp, mat3 tbn, vec3 position, vec3 positionWorld) {
vec3 n = normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));
vec3 v = vposEyeDir;
vec3 final = getSeaColor(n, v, mainLightDirection, colorInput.rgb, mainLightIntensity, localUp, 1.0 - shadow, maskInput.w, position, positionWorld);
return vec4(final, colorInput.w);
}`))}function Ol(t,e){var r,i,s;return t.identifier===We.Material&&t.output===M.Color?(r=e.overlay)==null?void 0:r.getTexture(Y.ColorNoRasterImage):t.identifier===We.Material&&t.output===M.ObjectAndLayerIdColor?(i=e.overlay)==null?void 0:i.getTexture(Y.ObjectAndLayerIdColor):t.identifier===We.Highlight?(s=e.overlay)==null?void 0:s.getTexture(Y.Highlight):null}function bl(t,e){var s,a,o,n;const r=(a=(s=e.overlay)==null?void 0:s.overlays[be.INNER])==null?void 0:a.extent;Dr(r)&&(Pe[0]=t.toMapSpace[0]/Tt(r)-r[0]/Tt(r),Pe[1]=t.toMapSpace[1]/Rt(r)-r[1]/Rt(r));const i=(n=(o=e.overlay)==null?void 0:o.overlays[be.OUTER])==null?void 0:n.extent;return Dr(i)&&(Pe[2]=t.toMapSpace[0]/Tt(i)-i[0]/Tt(i),Pe[3]=t.toMapSpace[1]/Rt(i)-i[1]/Rt(i)),Pe}function Al(t,e){var s,a,o,n;const r=(a=(s=e.overlay)==null?void 0:s.overlays[be.INNER])==null?void 0:a.extent;Dr(r)&&(Pe[0]=t.toMapSpace[2]/Tt(r),Pe[1]=t.toMapSpace[3]/Rt(r));const i=(n=(o=e.overlay)==null?void 0:o.overlays[be.OUTER])==null?void 0:n.extent;return Dr(i)&&(Pe[2]=t.toMapSpace[2]/Tt(i),Pe[3]=t.toMapSpace[3]/Rt(i)),Pe}const Pe=Ve();let xa=class extends ha{constructor(){super(...arguments),this.color=st(1,1,1)}};function Dl(){const t=new Ei;return t.include(ca),t.fragment.uniforms.add(new ke("tex",e=>e.texture),new et("uColor",e=>e.color)),t.fragment.code.add(w`void main() {
vec4 texColor = texture(tex, uv);
fragColor = texColor * vec4(uColor, 1.0);
}`),t}const Ml=Object.freeze(Object.defineProperty({__proto__:null,TextureOnlyPassParameters:xa,build:Dl},Symbol.toStringTag,{value:"Module"}));let El=class{constructor(e){this._context=e,this._perConstructorInstances=new Fi,this._frameCounter=0,this._keepAliveFrameCount=bs}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}destroy(){this._perConstructorInstances.forEach(e=>e.forEach(r=>r.technique.destroy())),this._perConstructorInstances.clear()}acquire(e,r=Il){const i=r.key;let s=this._perConstructorInstances.get(e,i);if(s==null){const a=new e(this._context,r,()=>this.release(a));s=new $l(a),this._perConstructorInstances.set(e,i,s)}return++s.refCount,s.technique}releaseAndAcquire(e,r,i){if(i!=null){if(r.key===i.key)return i;this.release(i)}return this.acquire(e,r)}release(e){if(e==null||this._perConstructorInstances.empty)return;const r=this._perConstructorInstances.get(e.constructor,e.key);r!=null&&(--r.refCount,r.refCount===0&&(r.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==bs&&this._perConstructorInstances.forEach((e,r)=>{e.forEach((i,s)=>{i.refCount===0&&i.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(i.technique.destroy(),this._perConstructorInstances.delete(r,s))})})}async reloadAll(){const e=new Array;this._perConstructorInstances.forEach((r,i)=>{const s=async(a,o)=>{const n=o.shader;n&&(await n.reload(),a.forEach(c=>c.technique.reload(this._context)))};e.push(s(r,i))}),await Promise.all(e)}},$l=class{constructor(e){this.technique=e,this.refCount=0,this.refZeroFrame=0}};const bs=-1,Il=new pa;function Pl(t,e,r){return 2*Math.atan(Math.sqrt(e*e+r*r)*Math.tan(.5*t)/e)}function Ll(t,e,r){return 2*Math.atan(Math.sqrt(e*e+r*r)*Math.tan(.5*t)/r)}function Fl(t,e,r){return 2*Math.atan(e*Math.tan(.5*t)/Math.sqrt(e*e+r*r))}function Nl(t,e,r){return 2*Math.atan(r*Math.tan(.5*t)/Math.sqrt(e*e+r*r))}var yi;let I=yi=class extends ra{constructor(t){super(t),this._ray=io(),this._viewport=pi(0,0,1,1),this._padding=pi(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=so(1,1e3),this._viewDirty=!0,this._viewMatrix=W(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=W(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=W(),this._frustumDirty=!0,this._frustum=wn(),this._fullViewport=Ve(),this._pixelRatio=1,this.row=0,this.column=0,this._rows=1,this._columns=1,this._center=E(),this._up=E(),this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t>0?t:1}get rows(){return this._rows}set rows(t){this._rows=Math.max(1,t)}get columns(){return this._columns}set columns(t){this._columns=Math.max(1,t)}get eye(){return this._ray.origin}set eye(t){this._compareAndSetView(t,this._ray.origin)}get center(){return this._center}set center(t){this._compareAndSetView(t,this._center,"_center")}get ray(){return ae(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(t){this._compareAndSetView(t,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(t){it(this._viewMatrix,t),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),Q(E(),-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10])}get viewUp(){return this._ensureViewClean(),Q(E(),this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9])}get viewRight(){return this._ensureViewClean(),Q(E(),this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8])}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(t){this._nearFar[0]!==t&&(this._nearFar[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(t){this._nearFar[1]!==t&&(this._nearFar[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(t){this.x=t[0],this.y=t[1],this.width=t[2],this.height=t[3]}get screenViewport(){if(this.pixelRatio===1)return this._viewport;const t=Gi(Ve(),this._viewport,1/this.pixelRatio),e=this._get("screenViewport");return e&&Wi(t,e)?e:t}get screenPadding(){if(this.pixelRatio===1)return this._padding;const t=Gi(Ve(),this._padding,1/this.pixelRatio),e=this._get("screenPadding");return e&&Wi(t,e)?e:t}get x(){return this._viewport[0]}set x(t){t+=this._padding[z.LEFT],this._viewport[0]!==t&&(this._viewport[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(t){t+=this._padding[z.BOTTOM],this._viewport[1]!==t&&(this._viewport[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(t){this._viewport[2]!==t&&(this._viewport[2]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(t){this._viewport[3]!==t&&(this._viewport[3]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[z.RIGHT]+this._padding[z.LEFT]}set fullWidth(t){this.width=t-(this._padding[z.RIGHT]+this._padding[z.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[z.TOP]+this._padding[z.BOTTOM]}set fullHeight(t){this.height=t-(this._padding[z.TOP]+this._padding[z.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[z.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[z.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(t){Vr(this._padding,t)||(this._viewport[0]+=t[z.LEFT]-this._padding[z.LEFT],this._viewport[1]+=t[z.BOTTOM]-this._padding[z.BOTTOM],this._viewport[2]-=t[z.RIGHT]+t[z.LEFT]-(this._padding[z.RIGHT]+this._padding[z.LEFT]),this._viewport[3]-=t[z.TOP]+t[z.BOTTOM]-(this._padding[z.TOP]+this._padding[z.BOTTOM]),or(this._padding,t),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&(Be(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){const t=this.width,e=this.height,r=this.near*Math.tan(this.fovY/2)*2,i=r*this._aspect,s=r/this.rows,a=i/this.columns,o=-i/2+this.column*a,n=o+a,c=-r/2+this.row*s,l=c+s,d=ao(W(),o*(1+2*this._padding[z.LEFT]/t),n*(1+2*this._padding[z.RIGHT]/t),c*(1+2*this._padding[z.BOTTOM]/e),l*(1+2*this._padding[z.TOP]/e),this.near,this.far),h=this._get("projectionMatrix");return h&&oo(h,d)?h:d}get inverseProjectionMatrix(){return kt(W(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||W()}get fov(){return this._fov}set fov(t){this._fov=t,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return Fl(this._fov,this.width,this.height)}set fovX(t){this._fov=Pl(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return Nl(this._fov,this.width,this.height)}set fovY(t){this._fov=Ll(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return jr(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(kt(this._viewInverseTransposeMatrix,this.viewMatrix),ia(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(t){const e=2*t-1;return 2*this.near*this.far/(this.far+this.near-e*(this.far-this.near))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return this.relativeElevation!=null&&this.relativeElevation>=0}copyFrom(t){X(this._ray.origin,t.eye),this.center=t.center,this.up=t.up,or(this._viewport,t.viewport),this.notifyChange("_viewport"),or(this._padding,t.padding),this.notifyChange("_padding"),Ri(this._nearFar,t.nearFar),this.notifyChange("_nearFar"),this._fov=t.fov,this.row=t.row,this.column=t.column,this.rows=t.rows,this.columns=t.columns,this.relativeElevation=t.relativeElevation;const e=t;return this._viewDirty=e._viewDirty,this._viewDirty||(it(this._viewMatrix,t.viewMatrix),this.notifyChange("_viewMatrix")),this._viewProjectionDirty=!0,this._frustumDirty=e._frustumDirty,this._frustumDirty||(xn(this._frustum,t.frustum),this._frustumDirty=!1),e._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(it(this._viewInverseTransposeMatrix,t.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),or(this._fullViewport,t.fullViewport),this.pixelRatio=t.pixelRatio,this}copyViewFrom(t){this.eye=t.eye,this.center=t.center,this.up=t.up}clone(){return new yi().copyFrom(this)}equals(t){return St(this.eye,t.eye)&&St(this.center,t.center)&&St(this.up,t.up)&&Vr(this._viewport,t.viewport)&&Vr(this._padding,t.padding)&&no(this.nearFar,t.nearFar)&&this._fov===t.fov&&this.pixelRatio===t.pixelRatio&&this.relativeElevation===t.relativeElevation&&this.row===t.row&&this.column===t.column&&this.rows===t.rows&&this.columns===t.columns}almostEquals(t){const e=Math.max(1,1/this.pixelRatio,1/t.pixelRatio);if(Math.abs(t.fov-this._fov)>=.001||Bi(t.screenPadding,this.screenPadding)>=e||Bi(this.screenViewport,t.screenViewport)>=e||this.row!==t.row||this.column!==t.column||this.rows!==t.rows||this.columns!==t.columns)return!1;ki(oe,t.eye,t.center),ki(Qr,this.eye,this.center);const r=Lt(oe,Qr),i=qi(oe),s=qi(Qr),a=5e-4;return r*r>=(1-1e-10)*i*s&&lo(t.eye,this.eye)<Math.max(i,s)*a*a}computeRenderPixelSizeAt(t){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t))}computeRenderPixelSizeAtDist(t){return t*this.perRenderPixelRatio}computeScreenPixelSizeAt(t){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t))}_viewDirectionDistance(t){return Math.abs(co(this.viewForward,ae(oe,t,this.eye)))}computeScreenPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeDistanceFromRadius(t,e){return t/Math.tan(Math.min(this.fovX,this.fovY)/(2*(e||1)))}getScreenCenter(t=ho()){return t[0]=(this.padding[z.LEFT]+this.width/2)/this.pixelRatio,t[1]=(this.padding[z.TOP]+this.height/2)/this.pixelRatio,t}getRenderCenter(t,e=.5,r=.5){return t[0]=this.padding[z.LEFT]+this.width*e,t[1]=this.padding[z.BOTTOM]+this.height*r,t[2]=.5,t}setGLViewport(t){const e=this.viewport,r=this.padding;t.setViewport(e[0]-r[3],e[1]-r[2],e[2]+r[1]+r[3],e[3]+r[0]+r[2])}applyProjection(t,e){t!==L&&X(L,t),L[3]=1,Ht(L,L,this.projectionMatrix);const r=Math.abs(L[3]);se(L,L,1/r);const i=this.fullViewport;e[0]=Gt(0,i[0]+i[2],.5+.5*L[0]),e[1]=Gt(0,i[1]+i[3],.5+.5*L[1]),e[2]=.5*(L[2]+1),e[3]=r}unapplyProjection(t,e){const r=this.fullViewport;L[0]=(t[0]/(r[0]+r[2])*2-1)*t[3],L[1]=(t[1]/(r[1]+r[3])*2-1)*t[3],L[2]=(2*t[2]-1)*t[3],L[3]=t[3],this.inverseProjectionMatrix!=null&&(Ht(L,L,this.inverseProjectionMatrix),e[0]=L[0],e[1]=L[1],e[2]=L[2])}projectToScreen(t,e){return this.projectToRenderScreen(t,Jr),this.renderToScreen(Jr,e),e}projectToRenderScreen(t,e){if(L[0]=t[0],L[1]=t[1],L[2]=t[2],L[3]=1,Ht(L,L,this.viewProjectionMatrix),L[3]===0)return null;const r=L;se(r,r,1/Math.abs(L[3]));const i=this.fullViewport,s=Gt(0,i[0]+i[2],.5+.5*r[0]),a=Gt(0,i[1]+i[3],.5+.5*r[1]);return"x"in e?(e.x=s,e.y=a):(e[0]=s,e[1]=a,e.length>2&&(e[2]=.5*(r[2]+1))),e}unprojectFromScreen(t,e){return this.unprojectFromRenderScreen(this.screenToRender(t,Jr),e)}unprojectFromRenderScreen(t,e){if(Be(hr,this.projectionMatrix,this.viewMatrix),!kt(hr,hr))return null;const r=this.fullViewport;return L[0]=2*(t[0]-r[0])/r[2]-1,L[1]=2*(t[1]-r[1])/r[3]-1,L[2]=2*t[2]-1,L[3]=1,Ht(L,L,hr),L[3]===0?null:(e[0]=L[0]/L[3],e[1]=L[1]/L[3],e[2]=L[2]/L[3],e)}constrainWindowSize(t,e,r,i){const s=t*this.pixelRatio,a=e*this.pixelRatio,o=Math.max(s-r/2,0),n=Math.max(this.fullHeight-a-i/2,0),c=-Math.min(s-r/2,0),l=-Math.min(this.fullHeight-a-i/2,0),d=r-c- -Math.min(this.fullWidth-s-r/2,0),h=i-l- -Math.min(a-i/2,0);return[Math.round(o),Math.round(n),Math.round(d),Math.round(h)]}computeUp(t){t===Oi.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(t,e){const r=t[0]*this.pixelRatio,i=this.fullHeight-t[1]*this.pixelRatio;return e[0]=r,e[1]=i,e}renderToScreen(t,e){const r=t[0]/this.pixelRatio,i=(this.fullHeight-t[1])/this.pixelRatio;e[0]=r,e[1]=i}_computeUpGlobal(){ae(oe,this.center,this.eye);const t=Jt(this.center);t<1?(Q(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs(Lt(oe,this.center))>.9999*Jt(oe)*t||(Le(this._up,oe,this.center),Le(this._up,this._up,oe),re(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){uo(oe,this.eye,this.center),Math.abs(oe[2])<=.9999&&(se(oe,oe,oe[2]),Q(this._up,-oe[0],-oe[1],1-oe[2]),re(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(t,e,r=""){typeof t[0]=="number"&&isFinite(t[0])&&typeof t[1]=="number"&&isFinite(t[1])&&typeof t[2]=="number"&&isFinite(t[2])?St(t,e)||(X(e,t),this._markViewDirty(),r.length&&this.notifyChange(r)):zr.getLogger("esri.views.3d.webgl-engine.lib.Camera").warn("Camera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&(Cn(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(sa(this._viewMatrix,this.eye,this.center,this.up),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};m([b()],I.prototype,"_viewport",void 0),m([b()],I.prototype,"_padding",void 0),m([b()],I.prototype,"_fov",void 0),m([b()],I.prototype,"_nearFar",void 0),m([b()],I.prototype,"_viewDirty",void 0),m([b()],I.prototype,"_viewMatrix",void 0),m([b()],I.prototype,"_pixelRatio",void 0),m([b()],I.prototype,"pixelRatio",null),m([b()],I.prototype,"row",void 0),m([b()],I.prototype,"column",void 0),m([b()],I.prototype,"_rows",void 0),m([b()],I.prototype,"rows",null),m([b()],I.prototype,"_columns",void 0),m([b()],I.prototype,"columns",null),m([b()],I.prototype,"eye",null),m([b()],I.prototype,"center",null),m([b()],I.prototype,"_center",void 0),m([b()],I.prototype,"up",null),m([b()],I.prototype,"_up",void 0),m([b({readOnly:!0})],I.prototype,"viewForward",null),m([b({readOnly:!0})],I.prototype,"viewUp",null),m([b({readOnly:!0})],I.prototype,"viewRight",null),m([b({readOnly:!0})],I.prototype,"nearFar",null),m([b()],I.prototype,"near",null),m([b()],I.prototype,"far",null),m([b()],I.prototype,"viewport",null),m([b({readOnly:!0})],I.prototype,"screenViewport",null),m([b({readOnly:!0})],I.prototype,"screenPadding",null),m([b()],I.prototype,"x",null),m([b()],I.prototype,"y",null),m([b()],I.prototype,"width",null),m([b()],I.prototype,"height",null),m([b()],I.prototype,"fullWidth",null),m([b()],I.prototype,"fullHeight",null),m([b({readOnly:!0})],I.prototype,"_aspect",null),m([b()],I.prototype,"padding",null),m([b({readOnly:!0})],I.prototype,"projectionMatrix",null),m([b({readOnly:!0})],I.prototype,"inverseProjectionMatrix",null),m([b()],I.prototype,"fov",null),m([b()],I.prototype,"fovX",null),m([b()],I.prototype,"fovY",null),I=yi=m([tr("esri.views.3d.webgl-engine.lib.Camera")],I);const L=Ve(),hr=W(),oe=E(),Qr=E(),Jr=Ke();var z;(function(t){t[t.TOP=0]="TOP",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.LEFT=3]="LEFT"})(z||(z={}));let jl=class{constructor(e,r,i,s){this._textureRepository=e,this._techniqueRepository=r,this.materialChanged=i,this.requestRender=s,this._id2glMaterialRef=new Fi}dispose(){this._textureRepository.destroy()}acquire(e,r,i){this._ownMaterial(e);const s=e.produces.get(r);if(!s||!s(i))return null;let a=this._id2glMaterialRef.get(i,e.id);if(a==null){const o=e.createGLMaterial({material:e,techniqueRep:this._techniqueRepository,textureRepository:this._textureRepository,output:i});a=new zl(o),this._id2glMaterialRef.set(i,e.id,a)}return a.ref(),a.glMaterial}release(e,r){const i=this._id2glMaterialRef.get(r,e.id);i!=null&&(i.unref(),i.referenced||(Yt(i.glMaterial),this._id2glMaterialRef.delete(r,e.id)))}_ownMaterial(e){e.repository&&e.repository!==this&&zr.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"),e.repository=this}},zl=class{constructor(e){this.glMaterial=e,this._refCnt=0}ref(){++this._refCnt}unref(){--this._refCnt,pe(this._refCnt>=0)}get referenced(){return this._refCnt>0}};var at,er;(function(t){t[t.Draped=0]="Draped",t[t.Screen=1]="Screen",t[t.World=2]="World",t[t.COUNT=3]="COUNT"})(at||(at={})),function(t){t[t.Center=0]="Center",t[t.Tip=1]="Tip",t[t.COUNT=2]="COUNT"}(er||(er={}));let ee=class extends da{constructor(){super(...arguments),this.output=M.Color,this.transparencyPassType=Ue.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.writeDepth=!1,this.space=at.Screen,this.hideOnShortSegments=!1,this.hasCap=!1,this.anchor=er.Center,this.hasTip=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.hasOccludees=!1,this.multipassEnabled=!1,this.cullAboveGround=!1}get draped(){return this.space===at.Draped}};m([P({count:M.COUNT})],ee.prototype,"output",void 0),m([P({count:Ue.COUNT})],ee.prototype,"transparencyPassType",void 0),m([P()],ee.prototype,"occluder",void 0),m([P()],ee.prototype,"hasSlicePlane",void 0),m([P()],ee.prototype,"writeDepth",void 0),m([P({count:at.COUNT})],ee.prototype,"space",void 0),m([P()],ee.prototype,"hideOnShortSegments",void 0),m([P()],ee.prototype,"hasCap",void 0),m([P({count:er.COUNT})],ee.prototype,"anchor",void 0),m([P()],ee.prototype,"hasTip",void 0),m([P()],ee.prototype,"vvSize",void 0),m([P()],ee.prototype,"vvColor",void 0),m([P()],ee.prototype,"vvOpacity",void 0),m([P()],ee.prototype,"hasOccludees",void 0),m([P()],ee.prototype,"multipassEnabled",void 0),m([P()],ee.prototype,"cullAboveGround",void 0),m([P({constValue:!1})],ee.prototype,"occlusionPass",void 0),m([P({constValue:!0})],ee.prototype,"hasVvInstancing",void 0),m([P({constValue:!0})],ee.prototype,"hasSliceTranslatedView",void 0);const As=8;function Vl(t,e){const r=t.vertex;r.uniforms.add(new Z("intrinsicWidth",i=>i.width)),e.vvSize?(t.attributes.add(v.SIZEFEATUREATTRIBUTE,"float"),r.uniforms.add(new et("vvSizeMinSize",i=>i.vvSize.minSize),new et("vvSizeMaxSize",i=>i.vvSize.maxSize),new et("vvSizeOffset",i=>i.vvSize.offset),new et("vvSizeFactor",i=>i.vvSize.factor)),r.code.add(w`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)):(t.attributes.add(v.SIZE,"float"),r.code.add(w`float getSize(){
return intrinsicWidth * size;
}`)),e.vvOpacity?(t.attributes.add(v.OPACITYFEATUREATTRIBUTE,"float"),r.constants.add("vvOpacityNumber","int",8),r.uniforms.add(new rs("vvOpacityValues",i=>i.vvOpacity.values,As),new rs("vvOpacityOpacities",i=>i.vvOpacity.opacityValues,As)),r.code.add(w`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)):r.code.add(w`vec4 applyOpacity( vec4 color ){
return color;
}`),e.vvColor?(t.include(zo,e),t.attributes.add(v.COLORFEATUREATTRIBUTE,"float"),r.code.add(w`vec4 getColor(){
return applyOpacity(interpolateVVColor(colorFeatureAttribute));
}`)):(t.attributes.add(v.COLOR,"vec4"),r.code.add(w`vec4 getColor(){
return applyOpacity(color);
}`))}let Ul=class{constructor(e,r,i){this._createTexture=e,this._parametersKey=r,this._repository=new Map,this._orphanCache=i.newCache(`procedural-texture-repository:${bi()}`,s=>s.dispose())}destroy(){for(const[e,{texture:r}]of this._repository)r.dispose();this._repository.clear(),this._orphanCache.destroy()}swap(e,r=null){const i=this._acquire(e);return this.release(r),i}release(e){if(e==null)return;const r=this._parametersKey(e),i=this._repository.get(r);if(i&&(i.refCount--,i.refCount===0)){this._repository.delete(r);const{texture:s}=i,a=s.usedMemory;this._orphanCache.put(r,s,a)}}_acquire(e){if(e==null)return null;const r=this._parametersKey(e),i=this._repository.get(r);if(i)return i.refCount++,i.texture;const s=this._orphanCache.pop(r)??this._createTexture(e),a=new Hl(s);return this._repository.set(r,a),s}},Hl=class{constructor(e){this.texture=e,this.refCount=1}};function zh(t,e){return new Ul(r=>{const{encodedData:i,textureSize:s}=Gl(r),a=new Ni;return a.internalFormat=_a.RGBA,a.width=s,a.height=1,a.wrapMode=Er.REPEAT,new Xt(t,a,i)},r=>`${r.pattern.join(",")}-r${r.pixelRatio}`,e)}function Gl(t){const e=zi(t),r=1/t.pixelRatio,i=Ca(t),s=Sa(t),a=(Math.floor(.5*(s-1))+.5)*r,o=[];let n=1;for(const u of e){for(let p=0;p<u;p++){const f=n*(Math.min(p,u-1-p)+.5)*r/a*.5+.5;o.push(f)}n=-n}const c=Math.round(e[0]/2),l=[...o.slice(c),...o.slice(0,c)],d=new Uint8Array(4*i);let h=0;for(const u of l)ga(u,d,h),h+=4;return{encodedData:d,textureSize:i}}function zi(t){return t.pattern.map(e=>Math.round(e*t.pixelRatio))}function Ca(t){if(t==null)return 1;const e=zi(t);return Math.floor(e.reduce((r,i)=>r+i))}function Sa(t){return zi(t).reduce((e,r)=>Math.max(e,r))}function Wl(t){return t==null?po:t.length===4?t:fi(Bl,t[0],t[1],t[2],1)}const Bl=Ve();function kl(t,e){t.constants.add("stippleAlphaColorDiscard","float",.001),t.constants.add("stippleAlphaHighlightDiscard","float",.5),e.stippleEnabled?ql(t,e):Zl(t)}function ql(t,e){const r=!(e.draped&&e.stipplePreferContinuous),{vertex:i,fragment:s}=t;s.include(Vo),e.draped||(Uo(i,e),i.uniforms.add(new Z("worldToScreenPerDistanceRatio",(a,o)=>1/o.camera.perScreenPixelRatio)),i.code.add(w`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)),t.varyings.add("vStippleDistance","float"),t.varyings.add("vStippleDistanceLimits","vec2"),t.varyings.add("vStipplePatternStretch","float"),i.code.add(w`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${Jl};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `),i.code.add(w`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),i.code.add(w`
    if (segmentLengthPseudoScreen >= ${r?"patternLength":"1e4"}) {
  `),$i(i),i.code.add(w`float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
float segmentLengthScreenRounded = flooredRepetitions * patternLength;
float stretch = repetitions / flooredRepetitions;
vStipplePatternStretch = max(0.75, stretch);
return vec2(0.0, segmentLengthScreenRounded);
}
return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
}`),s.uniforms.add(new ke("stipplePatternTexture",a=>a.stippleTexture),new Z("stipplePatternSDFNormalizer",a=>Ql(a.stipplePattern)),new Z("stipplePatternPixelSizeInv",a=>1/Ta(a))),s.code.add(w`float getStippleSDF(out bool isClamped) {
float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;
float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv * vLineSizeInv;
u = fract(u);
float encodedSDF = rgba2float(texture(stipplePatternTexture, vec2(u, 0.5)));
float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;
return (sdf - 0.5) * vStipplePatternStretch + 0.5;
}
float getStippleSDF() {
bool ignored;
return getStippleSDF(ignored);
}
float getStippleAlpha() {
bool isClamped;
float stippleSDF = getStippleSDF(isClamped);
float antiAliasedResult = clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);
return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
}`),e.stippleOffColorEnabled?(s.uniforms.add(new xr("stippleOffColor",a=>Wl(a.stippleOffColor))),s.code.add(w`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):s.code.add(w`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function Zl(t){t.fragment.code.add(w`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}function Ql(t){return t?(Math.floor(.5*(Sa(t)-1))+.5)/t.pixelRatio:1}function Ta(t){const e=t.stipplePattern;return e?Ca(t.stipplePattern)/e.pixelRatio:1}const Jl=w.float(.4),Ra=128,Oa=.5;function Vh(t){return t==="cross"||t==="x"}function Uh(t,e=Ra,r=e*Oa,i=0){const s=ba(t,e,r,i);return new Ho(s,{mipmap:!1,wrap:{s:Er.CLAMP_TO_EDGE,t:Er.CLAMP_TO_EDGE},width:e,height:e,components:4,noUnpackFlip:!0,reloadable:!0})}function ba(t,e=Ra,r=e*Oa,i=0){switch(t){case"circle":default:return Yl(e,r);case"square":return Xl(e,r);case"cross":return ec(e,r,i);case"x":return tc(e,r,i);case"kite":return Kl(e,r);case"triangle":return rc(e,r);case"arrow":return ic(e,r)}}function Yl(t,e){const r=t/2-.5;return ir(t,Ma(r,r,e/2))}function Xl(t,e){return Aa(t,e,!1)}function Kl(t,e){return Aa(t,e,!0)}function ec(t,e,r=0){return Da(t,e,!1,r)}function tc(t,e,r=0){return Da(t,e,!0,r)}function rc(t,e){return ir(t,Ea(t/2,e,e/2))}function ic(t,e){const r=e,i=e/2,s=t/2,a=.8*r,o=Ma(s,(t-e)/2-a,Math.sqrt(a*a+i*i)),n=Ea(s,r,i);return ir(t,(c,l)=>Math.max(n(c,l),-o(c,l)))}function Aa(t,e,r){return r&&(e/=Math.SQRT2),ir(t,(i,s)=>{let a=i-.5*t+.25,o=.5*t-s-.75;if(r){const n=(a+o)/Math.SQRT2;o=(o-a)/Math.SQRT2,a=n}return Math.max(Math.abs(a),Math.abs(o))-.5*e})}function Da(t,e,r,i=0){e-=i,r&&(e*=Math.SQRT2);const s=.5*e;return ir(t,(a,o)=>{let n,c=a-.5*t,l=.5*t-o-1;if(r){const d=(c+l)/Math.SQRT2;l=(l-c)/Math.SQRT2,c=d}return c=Math.abs(c),l=Math.abs(l),n=c>l?c>s?Math.sqrt((c-s)*(c-s)+l*l):l:l>s?Math.sqrt(c*c+(l-s)*(l-s)):c,n-=i/2,n})}function Ma(t,e,r){return(i,s)=>{const a=i-t,o=s-e;return Math.sqrt(a*a+o*o)-r}}function Ea(t,e,r){const i=Math.sqrt(e*e+r*r);return(s,a)=>{const o=Math.abs(s-t)-r,n=a-t+e/2+.75,c=(e*o+r*n)/i,l=-n;return Math.max(c,l)}}function ir(t,e){const r=new Uint8Array(4*t*t);for(let i=0;i<t;i++)for(let s=0;s<t;s++){const a=s+t*i;let o=e(s,i);o=o/t+.5,ga(o,r,4*a)}return r}const Qt=64,$a=Qt/2,Ia=$a/5,sc=Qt/Ia,Hh=.25;function Gh(t,e){const r=ba(t,Qt,$a,Ia),i=new Ni;return i.internalFormat=_a.RGBA,i.width=Qt,i.height=Qt,i.wrapMode=Er.CLAMP_TO_EDGE,new Xt(e,i,r)}function ac(t,e){const{vertex:r,constants:i}=t;i.add("markerSizePerLineWidth","float",sc),$i(r),r.uniforms.get("markerScale")==null&&r.constants.add("markerScale","float",1),r.code.add(w`float getLineWidth() {
return max(getSize(), 1.0) * pixelRatio;
}
float getScreenMarkerSize() {
return markerSizePerLineWidth * markerScale * getLineWidth();
}`),e.space===at.World&&(r.constants.add("maxSegmentLengthFraction","float",.45),r.uniforms.add(new Z("perRenderPixelRatio",(s,a)=>a.camera.perRenderPixelRatio)),r.code.add(w`bool areWorldMarkersHidden(vec4 pos, vec4 other) {
vec3 midPoint = mix(pos.xyz, other.xyz, 0.5);
float distanceToCamera = length(midPoint);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
float worldMarkerSize = getScreenMarkerSize() * screenToWorldRatio;
float segmentLen = length(pos.xyz - other.xyz);
return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
}
float getWorldMarkerSize(vec4 pos) {
float distanceToCamera = length(pos.xyz);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
return getScreenMarkerSize() * screenToWorldRatio;
}`))}var ot;(function(t){t[t.BUTT=0]="BUTT",t[t.SQUARE=1]="SQUARE",t[t.ROUND=2]="ROUND",t[t.COUNT=3]="COUNT"})(ot||(ot={}));let H=class extends da{constructor(){super(...arguments),this.output=M.Color,this.capType=ot.BUTT,this.transparencyPassType=Ue.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.writeDepth=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stipplePreferContinuous=!0,this.roundJoins=!1,this.applyMarkerOffset=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.falloffEnabled=!1,this.innerColorEnabled=!1,this.hasOccludees=!1,this.multipassEnabled=!1,this.cullAboveGround=!1,this.wireframe=!1,this.objectAndLayerIdColorInstanced=!1}};m([P({count:M.COUNT})],H.prototype,"output",void 0),m([P({count:ot.COUNT})],H.prototype,"capType",void 0),m([P({count:Ue.COUNT})],H.prototype,"transparencyPassType",void 0),m([P()],H.prototype,"occluder",void 0),m([P()],H.prototype,"hasSlicePlane",void 0),m([P()],H.prototype,"hasPolygonOffset",void 0),m([P()],H.prototype,"writeDepth",void 0),m([P()],H.prototype,"draped",void 0),m([P()],H.prototype,"stippleEnabled",void 0),m([P()],H.prototype,"stippleOffColorEnabled",void 0),m([P()],H.prototype,"stipplePreferContinuous",void 0),m([P()],H.prototype,"roundJoins",void 0),m([P()],H.prototype,"applyMarkerOffset",void 0),m([P()],H.prototype,"vvSize",void 0),m([P()],H.prototype,"vvColor",void 0),m([P()],H.prototype,"vvOpacity",void 0),m([P()],H.prototype,"falloffEnabled",void 0),m([P()],H.prototype,"innerColorEnabled",void 0),m([P()],H.prototype,"hasOccludees",void 0),m([P()],H.prototype,"multipassEnabled",void 0),m([P()],H.prototype,"cullAboveGround",void 0),m([P()],H.prototype,"wireframe",void 0),m([P()],H.prototype,"objectAndLayerIdColorInstanced",void 0),m([P({constValue:!1})],H.prototype,"occlusionPass",void 0),m([P({constValue:!0})],H.prototype,"hasVvInstancing",void 0),m([P({constValue:!0})],H.prototype,"hasSliceTranslatedView",void 0);const Fr=1;function oc(t){const e=new Ei,{attributes:r,varyings:i,constants:s,vertex:a,fragment:o}=e;e.include(Go),e.include(Vl,t),e.include(kl,t);const n=t.applyMarkerOffset&&!t.draped;n&&(a.uniforms.add(new Z("markerScale",f=>f.markerScale)),e.include(ac,{space:at.World,draped:!1})),t.output===M.LinearDepth&&e.include(Wo,t),e.include(Bo,t),ko(a,t),a.uniforms.add(new Ft("inverseProjectionMatrix",(f,y)=>y.camera.inverseProjectionMatrix),new Di("nearFar",(f,y)=>y.camera.nearFar),new Z("miterLimit",f=>f.join!=="miter"?0:f.miterLimit),new xr("viewport",(f,y)=>y.camera.fullViewport)),a.constants.add("LARGE_HALF_FLOAT","float",65500),r.add(v.POSITION,"vec3"),r.add(v.PREVPOSITION,"vec3"),r.add(v.NEXTPOSITION,"vec3"),r.add(v.SUBDIVISIONFACTOR,"float"),r.add(v.UV0,"vec2"),i.add("vColor","vec4"),i.add("vpos","vec3"),i.add("vLineDistance","float"),i.add("vLineWidth","float"),qo(e);const c=t.multipassEnabled&&(t.output===M.Color||t.output===M.Alpha);c&&i.add("depth","float");const l=t.stippleEnabled;l&&i.add("vLineSizeInv","float"),s.add("aaWidth","float",t.stippleEnabled?0:1);const d=t.capType===ot.ROUND,h=t.stippleEnabled&&d,u=t.falloffEnabled||h;u&&i.add("vLineDistanceNorm","float"),d&&(i.add("vSegmentSDF","float"),i.add("vReverseSegmentSDF","float")),a.code.add(w`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`),a.code.add(w`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`),Zo(e),a.code.add(w`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = nearFar[0] * 0.99;

      if(pos.z > -nearFar[0]) {
        //current pos behind ncp --> we need to clip
        if (!isStartVertex) {
          if(prev.z < -nearFar[0]) {
            //previous in front of ncp
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        } else {
          if(next.z < -nearFar[0]) {
            //next in front of ncp
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        if (prev.z > -nearFar[0]) {
          //previous behind ncp
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        if (next.z > -nearFar[0]) {
          //next behind ncp
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${c?"depth = pos.z;":""}
      linearDepth = calculateLinearDepth(nearFar,pos.z);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
  `),$i(a),a.code.add(w`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;
      float lineSize = getSize();

      if (lineSize < 1.0) {
        coverage = lineSize; // convert sub-pixel coverage to alpha
        lineSize = 1.0;
      }
      lineSize += aaWidth;

      float lineWidth = lineSize * pixelRatio;
      vLineWidth = lineWidth;
      ${l?w`vLineSizeInv = 1.0 / lineSize;`:""}

      vec4 pos  = view * vec4(position, 1.0);
      vec4 prev = view * vec4(prevPosition, 1.0);
      vec4 next = view * vec4(nextPosition, 1.0);
  `),n&&a.code.add(w`vec4 other = isStartVertex ? next : prev;
bool markersHidden = areWorldMarkersHidden(pos, other);
if(!isJoin && !markersHidden) {
pos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;
}`),a.code.add(w`clipAndTransform(pos, prev, next, isStartVertex);
vec2 left = (pos.xy - prev.xy);
vec2 right = (next.xy - pos.xy);
float leftLen = length(left);
float rightLen = length(right);`),(t.stippleEnabled||d)&&a.code.add(w`
      float isEndVertex = float(!isStartVertex);
      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);
      vec2 segment = mix(right, left, isEndVertex);
      ${d?w`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:""}
    `),a.code.add(w`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`),t.roundJoins?a.code.add(w`
        vec2 startDir = leftLen < 0.001 ? right : left;
        startDir = PERPENDICULAR(startDir);

        vec2 endDir = rightLen < 0.001 ? left : right;
        endDir = PERPENDICULAR(endDir);

        float factor = ${t.stippleEnabled?w`min(1.0, subdivisionFactor * ${w.float((Fr+2)/(Fr+1))})`:w`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);
      `):a.code.add(w`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);const p=t.capType!==ot.BUTT;return a.code.add(w`
        displacementLen = lineWidth;
      }
    } else {
      // CAP handling ---------------------------------------------------
      joinDisplacementDir = isStartVertex ? right : left;
      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);

      ${p?w`capDisplacementDir = isStartVertex ? -right : left;`:""}
    }
  `),a.code.add(w`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;
    float lineDistNorm = sign(uv0.y) * pos.w;

    vLineDistance =  lineWidth * lineDistNorm;
    ${u?w`vLineDistanceNorm = lineDistNorm;`:""}

    pos.xy += dpos;
  `),d&&a.code.add(w`vec2 segmentDir = normalize(segment);
vSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;
vReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),t.stippleEnabled&&(t.draped?a.uniforms.add(new Z("worldToScreenRatio",(f,y)=>1/y.screenToPCSRatio)):a.code.add(w`vec3 segmentCenter = mix((nextPosition + position) * 0.5, (position + prevPosition) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),a.code.add(w`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(nextPosition - position, position - prevPosition, isEndVertex));
vStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),t.draped?a.code.add(w`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):a.code.add(w`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),a.uniforms.add(new Z("stipplePatternPixelSize",f=>Ta(f))),a.code.add(w`float patternLength = lineSize * stipplePatternPixelSize;
vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);
vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);
if (segmentLengthScreenDouble >= 0.001) {
vec2 stippleDisplacement = pos.xy - segmentOrigin;
float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);
vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
}
vStippleDistanceLimits *= pos.w;
vStippleDistance *= pos.w;
vStippleDistanceLimits = isJoin ?
vStippleDistanceLimits :
isStartVertex ?
vec2(-1e34, vStippleDistanceLimits.y) :
vec2(vStippleDistanceLimits.x, 1e34);`)),a.code.add(w`
      // Convert back into NDC
      pos.xy = (pos.xy / viewport.zw) * pos.w;

      vColor = getColor();
      vColor.a *= coverage;

      ${t.wireframe&&!t.draped?"pos.z -= 0.001 * pos.w;":""}

      // transform final position to camera space for slicing
      vpos = (inverseProjectionMatrix * pos).xyz;
      gl_Position = pos;
      forwardObjectAndLayerIdColor();
    }
  }
  `),c&&e.include(Qo,t),e.include(Jo,t),o.include(Yo),o.code.add(w`
  void main() {
    discardBySlice(vpos);
    ${c?"terrainDepthTest(depth);":""}
  `),t.wireframe?o.code.add(w`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(d&&o.code.add(w`
        float sdf = min(vSegmentSDF, vReverseSegmentSDF);
        vec2 fragmentPosition = vec2(
          min(sdf, 0.0),
          vLineDistance
        ) * gl_FragCoord.w;

        float fragmentRadius = length(fragmentPosition);
        float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
        float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);

        if (capCoverage < ${w.float(Br)}) {
          discard;
        }
      `),h?o.code.add(w`
      vec2 stipplePosition = vec2(
        min(getStippleSDF() * 2.0 - 1.0, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${w.float(Br)}, stippleCoverage);
      `):o.code.add(w`float stippleAlpha = getStippleAlpha();`),t.output!==M.ObjectAndLayerIdColor&&o.code.add(w`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);`),o.uniforms.add(new xr("intrinsicColor",f=>f.color)),o.code.add(w`vec4 color = intrinsicColor * vColor;`),t.innerColorEnabled&&(o.uniforms.add(new xr("innerColor",f=>f.innerColor??f.color),new Z("innerWidth",(f,y)=>f.innerWidth*y.camera.pixelRatio)),o.code.add(w`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),o.code.add(w`vec4 finalColor = blendStipple(color, stippleAlpha);`),t.falloffEnabled&&(o.uniforms.add(new Z("falloff",f=>f.falloff)),o.code.add(w`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`)),t.stippleEnabled||o.code.add(w`float featherStartDistance = max(vLineWidth - 2.0, 0.0);
float value = abs(vLineDistance) * gl_FragCoord.w;
float feather = (value - featherStartDistance) / (vLineWidth - featherStartDistance);
finalColor.a *= 1.0 - clamp(feather, 0.0, 1.0);`)),o.code.add(w`
    ${t.output===M.ObjectAndLayerIdColor?w`finalColor.a = 1.0;`:""}

    if (finalColor.a < ${w.float(Br)}) {
      discard;
    }

    ${t.output===M.Alpha?w`fragColor = vec4(finalColor.a);`:""}
    ${t.output===M.Color?w`fragColor = highlightSlice(finalColor, vpos);`:""}
    ${t.output===M.Color&&t.transparencyPassType===Ue.Color?"fragColor = premultiplyAlpha(fragColor);":""}
    ${t.output===M.Highlight?w`fragColor = vec4(1.0);`:""}
    ${t.output===M.LinearDepth?w`outputDepth(linearDepth);`:""}
    ${t.output===M.ObjectAndLayerIdColor?w`outputObjectAndLayerIdColor();`:""}
  }
  `),e}const nc=Object.freeze(Object.defineProperty({__proto__:null,build:oc,ribbonlineNumRoundJoinSubdivisions:Fr},Symbol.toStringTag,{value:"Module"})),Pa=new Map([[v.POSITION,0],[v.PREVPOSITION,1],[v.NEXTPOSITION,2],[v.SUBDIVISIONFACTOR,3],[v.UV0,4],[v.COLOR,5],[v.COLORFEATUREATTRIBUTE,5],[v.SIZE,6],[v.SIZEFEATUREATTRIBUTE,6],[v.OPACITYFEATUREATTRIBUTE,7],[v.OBJECTANDLAYERIDCOLOR,8]]);let La=class Fa extends Ii{initializeProgram(e){return new Pi(e.rctx,Fa.shader.get().build(this.configuration),Pa)}_makePipelineState(e,r){const i=this.configuration,s=e===Ue.NONE,a=e===Ue.FrontFace,o=Xo(i.output);return tt({blending:i.output===M.Color||i.output===M.Alpha?s?Zr:In(e):null,depthTest:{func:Pn(e)},depthWrite:s?i.writeDepth||o?Ln:null:Fn(e),colorWrite:Et,stencilWrite:i.hasOccludees?is:null,stencilTest:i.hasOccludees?r?ss:Ko:null,polygonOffset:s||a?i.hasPolygonOffset?Ds:null:Nn})}initializePipeline(){const e=this.configuration;if(e.occluder){const r=e.hasPolygonOffset?Ds:null;this._occluderPipelineTransparent=tt({blending:Zr,polygonOffset:r,depthTest:as,depthWrite:null,colorWrite:Et,stencilWrite:null,stencilTest:en}),this._occluderPipelineOpaque=tt({blending:Zr,polygonOffset:r,depthTest:as,depthWrite:null,colorWrite:Et,stencilWrite:tn,stencilTest:rn}),this._occluderPipelineMaskWrite=tt({blending:null,polygonOffset:r,depthTest:sn,depthWrite:null,colorWrite:null,stencilWrite:is,stencilTest:ss})}return this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0),this._makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return this.configuration.wireframe?fs.LINES:fs.TRIANGLE_STRIP}getPipeline(e,r,i){return e?this._occludeePipelineState:this.configuration.occluder?i?this._occluderPipelineTransparent:r?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipeline()}};La.shader=new Li(nc,()=>Ai(()=>import("./ColorMaterial.glsl-9YKbkIUs.js").then(t=>t.R),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23])));const Ds={factor:0,units:-4};var me;(function(t){t[t.LEFT_JOIN_START=-2]="LEFT_JOIN_START",t[t.LEFT_JOIN_END=-1]="LEFT_JOIN_END",t[t.LEFT_CAP_START=-4]="LEFT_CAP_START",t[t.LEFT_CAP_END=-5]="LEFT_CAP_END",t[t.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",t[t.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",t[t.RIGHT_CAP_START=4]="RIGHT_CAP_START",t[t.RIGHT_CAP_END=5]="RIGHT_CAP_END"})(me||(me={}));let lc=class extends Po{constructor(e){super(e,new dc),this._configuration=new H,this.produces=new Map([[ie.OPAQUE_MATERIAL,r=>r===M.Highlight||r===M.ObjectAndLayerIdColor||(r===M.Color||r===M.Alpha)&&this.parameters.renderOccluded===Re.OccludeAndTransparentStencil],[ie.OPAQUE_NO_SSAO_DEPTH,r=>r===M.LinearDepth],[ie.OCCLUDER_MATERIAL,r=>os(r)&&this.parameters.renderOccluded===Re.OccludeAndTransparentStencil],[ie.TRANSPARENT_OCCLUDER_MATERIAL,r=>os(r)&&this.parameters.renderOccluded===Re.OccludeAndTransparentStencil],[ie.TRANSPARENT_MATERIAL,r=>(r===M.Color||r===M.Alpha)&&this.parameters.writeDepth&&this.parameters.renderOccluded!==Re.OccludeAndTransparentStencil],[ie.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,r=>(r===M.Color||r===M.Alpha)&&!this.parameters.writeDepth&&this.parameters.renderOccluded!==Re.OccludeAndTransparentStencil],[ie.DRAPED_MATERIAL,r=>an(r)]]),this._vertexAttributeLocations=Pa}getConfiguration(e,r){this._configuration.output=e,this._configuration.draped=r.slot===ie.DRAPED_MATERIAL;const i=this.parameters.stipplePattern!=null&&e!==M.Highlight;return this._configuration.stippleEnabled=i,this._configuration.stippleOffColorEnabled=i&&this.parameters.stippleOffColor!=null,this._configuration.stipplePreferContinuous=i&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins=this.parameters.join==="round",this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=this.parameters.markerParameters!=null&&uc(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&this.parameters.innerColor!=null,this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===Re.OccludeAndTransparentStencil,this._configuration.transparencyPassType=r.transparencyPassType,this._configuration.multipassEnabled=r.multipassEnabled,this._configuration.cullAboveGround=r.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersectDraped(e,r,i,s,a,o){if(!i.options.selectionMode)return;const n=e.attributes.get(v.POSITION).data,c=e.attributes.get(v.SIZE);let l=this.parameters.width;if(this.parameters.vvSize){const y=e.attributes.get(v.SIZEFEATUREATTRIBUTE).data[0];l*=Mt(this.parameters.vvSize.offset[0]+y*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else c&&(l*=c.data[0]);const d=s[0],h=s[1],u=(l/2+4)*e.screenToWorldRatio;let p=Number.MAX_VALUE,f=0;for(let y=0;y<n.length-5;y+=3){const x=n[y],R=n[y+1],C=d-x,_=h-R,O=n[y+3]-x,S=n[y+4]-R,A=Mt((O*C+S*_)/(O*O+S*S),0,1),g=O*A-C,U=S*A-_,V=g*g+U*U;V<p&&(p=V,f=y/3)}p<u*u&&a(o.dist,o.normal,f,!1)}intersect(e,r,i,s,a,o){if(!i.options.selectionMode||!e.visible)return;if(!Sn(r))return void zr.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const n=e.attributes,c=n.get(v.POSITION).data;let l=this.parameters.width;if(this.parameters.vvSize){const C=n.get(v.SIZEFEATUREATTRIBUTE).data[0];l*=Mt(this.parameters.vvSize.offset[0]+C*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else n.has(v.SIZE)&&(l*=n.get(v.SIZE).data[0]);const d=i.camera,h=pc;Ri(h,i.point);const u=l*d.pixelRatio/2+4*d.pixelRatio;Q(Vt[0],h[0]-u,h[1]+u,0),Q(Vt[1],h[0]+u,h[1]+u,0),Q(Vt[2],h[0]+u,h[1]-u,0),Q(Vt[3],h[0]-u,h[1]-u,0);for(let C=0;C<4;C++)if(!d.unprojectFromRenderScreen(Vt[C],ze[C]))return;nr(d.eye,ze[0],ze[1],Xr),nr(d.eye,ze[1],ze[2],Kr),nr(d.eye,ze[2],ze[3],ei),nr(d.eye,ze[3],ze[0],ti);let p=Number.MAX_VALUE,f=0;const y=Na(this.parameters,n)?c.length-2:c.length-5;for(let C=0;C<y;C+=3){de[0]=c[C]+r[12],de[1]=c[C+1]+r[13],de[2]=c[C+2]+r[14];const _=(C+3)%c.length;if(he[0]=c[_]+r[12],he[1]=c[_+1]+r[13],he[2]=c[_+2]+r[14],Me(Xr,de)<0&&Me(Xr,he)<0||Me(Kr,de)<0&&Me(Kr,he)<0||Me(ei,de)<0&&Me(ei,he)<0||Me(ti,de)<0&&Me(ti,he)<0)continue;if(d.projectToRenderScreen(de,Qe),d.projectToRenderScreen(he,Je),Qe[2]<0&&Je[2]>0){ae(Ee,de,he);const S=d.frustum,A=-Me(S[lr.NEAR],de)/Lt(Ee,Zi(S[lr.NEAR]));se(Ee,Ee,A),le(de,de,Ee),d.projectToRenderScreen(de,Qe)}else if(Qe[2]>0&&Je[2]<0){ae(Ee,he,de);const S=d.frustum,A=-Me(S[lr.NEAR],he)/Lt(Ee,Zi(S[lr.NEAR]));se(Ee,Ee,A),le(he,he,Ee),d.projectToRenderScreen(he,Je)}else if(Qe[2]<0&&Je[2]<0)continue;Qe[2]=0,Je[2]=0;const O=Mn(qr(Qe,Je,$s),h);O<p&&(p=O,X(Ms,de),X(Es,he),f=C/3)}const x=i.rayBegin,R=i.rayEnd;if(p<u*u){let C=Number.MAX_VALUE;if(En(qr(Ms,Es,$s),qr(x,R,fc),Ze)){ae(Ze,Ze,x);const _=Jt(Ze);se(Ze,Ze,1/_),C=_/jr(x,R)}o(C,Ze,f,!1)}}get _layout(){const e=$n().vec3f(v.POSITION).vec3f(v.PREVPOSITION).vec3f(v.NEXTPOSITION).f32(v.SUBDIVISIONFACTOR).vec2f(v.UV0);return this.parameters.vvSize?e.f32(v.SIZEFEATUREATTRIBUTE):e.f32(v.SIZE),this.parameters.vvColor?e.f32(v.COLORFEATUREATTRIBUTE):e.vec4f(v.COLOR),this.parameters.vvOpacity&&e.f32(v.OPACITYFEATUREATTRIBUTE),Dt("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(v.OBJECTANDLAYERIDCOLOR),e}createBufferWriter(){return new hc(this._layout,this.parameters)}createGLMaterial(e){return new cc(e)}validateParameters(e){e.join!=="miter"&&(e.miterLimit=0),e.markerParameters!=null&&(e.markerScale=e.markerParameters.width/e.width)}},cc=class extends on{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output!==M.Color&&this._output!==M.Alpha||this._updateOccludeeState(e);const r=this._material.parameters.stipplePattern;return this._stipplePattern!==r&&(this._material.setParameters({stippleTexture:this._stippleTextureRepository.swap(r,this._stipplePattern)}),this._stipplePattern=r),this.ensureTechnique(La,e)}},dc=class extends nn{constructor(){super(...arguments),this.width=0,this.color=fo,this.join="miter",this.cap=ot.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}},hc=class{constructor(e,r){this.vertexBufferLayout=e,this._parameters=r,this.numJoinSubdivisions=0;const i=r.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=i;break;case"round":this.numJoinSubdivisions=Fr+i}}_isClosed(e){return Na(this._parameters,e.attributes)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const i=e.attributes.get(v.POSITION).indices.length/2+1,s=this._isClosed(e);let a=s?2:2*2;return a+=((s?i:i-1)-(s?0:1))*(2*this.numJoinSubdivisions+4),a+=2,this._parameters.wireframe&&(a=2+4*(a-2)),a}write(e,r,i,s,a){var nt,sr,$;const o=mc,n=gc,c=_c,l=i.attributes.get(v.POSITION),d=l.indices,h=l.data.length/3,u=(nt=i.attributes.get(v.DISTANCETOSTART))==null?void 0:nt.data;d&&d.length!==2*(h-1)&&console.warn("RibbonLineMaterial does not support indices");const p=((sr=i.attributes.get(v.SIZEFEATUREATTRIBUTE))==null?void 0:sr.data[0])??(($=i.attributes.get(v.SIZE))==null?void 0:$.data[0])??1;let f=[1,1,1,1],y=0;const x=this.vertexBufferLayout.fields.has(v.COLORFEATUREATTRIBUTE);x?y=i.attributes.get(v.COLORFEATUREATTRIBUTE).data[0]:i.attributes.has(v.COLOR)&&(f=i.attributes.get(v.COLOR).data);const R=Dt("enable-feature:objectAndLayerId-rendering")?i.objectAndLayerIdColor:null,C=this.vertexBufferLayout.fields.has(v.OPACITYFEATUREATTRIBUTE),_=C?i.attributes.get(v.OPACITYFEATUREATTRIBUTE).data[0]:0,O=new Float32Array(s.buffer),S=Dt("enable-feature:objectAndLayerId-rendering")?new Uint8Array(s.buffer):null,A=this.vertexBufferLayout.stride/4;let g=a*A;const U=g;let V=0;const D=u?(B,K,ge)=>V=u[ge]:(B,K,ge)=>V+=jr(B,K),ce=Dt("enable-feature:objectAndLayerId-rendering"),N=(B,K,ge,je,lt,Ya,Xa)=>{if(O[g++]=K[0],O[g++]=K[1],O[g++]=K[2],O[g++]=B[0],O[g++]=B[1],O[g++]=B[2],O[g++]=ge[0],O[g++]=ge[1],O[g++]=ge[2],O[g++]=je,O[g++]=Xa,O[g++]=lt,O[g++]=p,x)O[g++]=y;else{const ar=Math.min(4*Ya,f.length-4);O[g++]=f[ar],O[g++]=f[ar+1],O[g++]=f[ar+2],O[g++]=f[ar+3]}C&&(O[g++]=_),ce&&(R!=null&&(S[4*g]=R[0],S[4*g+1]=R[1],S[4*g+2]=R[2],S[4*g+3]=R[3]),g++)};g+=A,Q(n,l.data[0],l.data[1],l.data[2]),e&&ye(n,n,e);const Fe=this._isClosed(i);if(Fe){const B=l.data.length-3;Q(o,l.data[B],l.data[B+1],l.data[B+2]),e&&ye(o,o,e)}else Q(c,l.data[3],l.data[4],l.data[5]),e&&ye(c,c,e),N(n,n,c,1,me.LEFT_CAP_START,0,0),N(n,n,c,1,me.RIGHT_CAP_START,0,0),X(o,n),X(n,c);const jt=Fe?0:1,Ne=Fe?h:h-1;for(let B=jt;B<Ne;B++){const K=(B+1)%h*3;Q(c,l.data[K],l.data[K+1],l.data[K+2]),e&&ye(c,c,e),D(o,n,B),N(o,n,c,0,me.LEFT_JOIN_END,B,V),N(o,n,c,0,me.RIGHT_JOIN_END,B,V);const ge=this.numJoinSubdivisions;for(let je=0;je<ge;++je){const lt=(je+1)/(ge+1);N(o,n,c,lt,me.LEFT_JOIN_END,B,V),N(o,n,c,lt,me.RIGHT_JOIN_END,B,V)}N(o,n,c,1,me.LEFT_JOIN_START,B,V),N(o,n,c,1,me.RIGHT_JOIN_START,B,V),X(o,n),X(n,c)}Fe?(Q(c,l.data[3],l.data[4],l.data[5]),e&&ye(c,c,e),V=D(o,n,Ne),N(o,n,c,0,me.LEFT_JOIN_END,jt,V),N(o,n,c,0,me.RIGHT_JOIN_END,jt,V)):(V=D(o,n,Ne),N(o,n,n,0,me.LEFT_CAP_END,Ne,V),N(o,n,n,0,me.RIGHT_CAP_END,Ne,V)),Yr(O,U+A,O,U,A),g=Yr(O,g-A,O,g,A),this._parameters.wireframe&&this._addWireframeVertices(s,U,g,A)}_addWireframeVertices(e,r,i,s){const a=new Float32Array(e.buffer,i*Float32Array.BYTES_PER_ELEMENT),o=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT,i-r);let n=0;const c=l=>n=Yr(o,l,a,n,s);for(let l=0;l<o.length-1;l+=2*s)c(l),c(l+2*s),c(l+1*s),c(l+2*s),c(l+1*s),c(l+3*s)}};function Yr(t,e,r,i,s){for(let a=0;a<s;a++)r[i++]=t[e++];return i}function Na(t,e){return t.isClosed?e.get(v.POSITION).indices.length>2:!1}function uc(t){return t.anchor===er.Tip&&t.hideOnShortSegments&&t.placement==="begin-end"&&t.worldSpace}const de=E(),he=E(),Ee=E(),Ze=E(),pc=E(),Qe=Ke(),Je=Ke(),Ms=E(),Es=E(),$s=ma(),fc=ma(),mc=E(),gc=E(),_c=E(),Vt=[Ke(),Ke(),Ke(),Ke()],ze=[E(),E(),E(),E()],Xr=rr(),Kr=rr(),ei=rr(),ti=rr();let vc=class{constructor(e){this._originSR=e,this._rootOriginId="root/"+bi(),this._origins=new Map,this._objects=new Map,this._gridSize=5e5}getOrigin(e){const r=this._origins.get(this._rootOriginId);if(r==null){const d=vi(e[0]+Math.random()-.5,e[1]+Math.random()-.5,e[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,d),d}const i=this._gridSize,s=Math.round(e[0]/i),a=Math.round(e[1]/i),o=Math.round(e[2]/i),n=`${s}/${a}/${o}`;let c=this._origins.get(n);const l=.5*i;if(ae(te,e,r.vec3),te[0]=Math.abs(te[0]),te[1]=Math.abs(te[1]),te[2]=Math.abs(te[2]),te[0]<l&&te[1]<l&&te[2]<l){if(c){const d=Math.max(...te);if(ae(te,e,c.vec3),te[0]=Math.abs(te[0]),te[1]=Math.abs(te[1]),te[2]=Math.abs(te[2]),Math.max(...te)<d)return c}return r}return c||(c=vi(s*i,a*i,o*i,n),this._origins.set(n,c)),c}_drawOriginBox(e,r=pi(1,1,0,1)){const i=window.view,s=i._stage,a=r.toString();if(!this._objects.has(a)){this._material=new lc({width:2,color:r}),s.add(this._material);const p=new nl(s,{pickable:!1}),f=new il({castShadow:!1});s.add(f),p.add(f),this._objects.set(a,f)}const o=this._objects.get(a),n=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],c=n.length,l=new Array(3*c),d=new Array,h=.5*this._gridSize;for(let p=0;p<c;p++)l[3*p]=e[0]+(1&n[p]?h:-h),l[3*p+1]=e[1]+(2&n[p]?h:-h),l[3*p+2]=e[2]+(4&n[p]?h:-h),p>0&&d.push(p-1,p);mi(l,this._originSR,0,l,i.renderSpatialReference,0,c);const u=new we(this._material,[[v.POSITION,new j(l,d,3,!0)]],null,Nt.Line);s.add(u),o.addGeometry(u)}get test(){const e=this;return{set gridSize(r){e._gridSize=r}}}};const te=E();var wi;(function(t){t[t.Occluded=0]="Occluded",t[t.NotOccluded=1]="NotOccluded",t[t.Both=2]="Both",t[t.COUNT=3]="COUNT"})(wi||(wi={}));function Jh(t){t.include(oa),t.uniforms.add(new ke("geometryDepthTexture",(e,r)=>{var i;return(i=r.multipassGeometry.linearDepth)==null?void 0:i.getTexture()}),new Di("nearFar",(e,r)=>r.camera.nearFar)),t.code.add(w`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos, nearFar);
return (elementDepth < (geometryDepth - 1.0));
}`)}let yc=class{},wc=class{constructor(e,r){this.shadowMap=e,this.slicePlane=r,this.slot=ie.OPAQUE_MATERIAL,this.hasOccludees=!1,this.enableFillLights=!0,this.transparencyPassType=Ue.NONE,this.alignPixelEnabled=!1,this.decorations=On.ON,this.overlayStretch=1,this._camera=new I,this._inverseViewport=k(),this.oldLighting=new kr,this.newLighting=new kr,this._fadedLighting=new kr,this._lighting=this.newLighting,this.ssr=new xc,this.multipassEnabled=!1,this.multipassTerrain=new ln,this.multipassGeometry=new yc,this.hudRenderStyle=wi.Occluded,this.cloudsFade=new _l}get camera(){return this._camera}set camera(e){this._camera=e,this._inverseViewport[0]=1/e.fullViewport[2],this._inverseViewport[1]=1/e.fullViewport[3]}get inverseViewport(){return this._inverseViewport}get lighting(){return this._lighting}get weatherFading(){return this._lighting===this._fadedLighting}fadeLighting(e){const{oldLighting:r,newLighting:i}=this;e>=1?this._lighting=i:(this._fadedLighting.lerpLighting(r,i,e),this._lighting=this._fadedLighting)}},xc=class{constructor(){this.fadeFactor=1,this.reprojectionMatrix=W()}},ja=class{constructor(e,r,i=null){this.rctx=e,this.sliceHelper=i,this.lastFrameCamera=new I,this.output=M.Color,this.renderOccludedMask=xi,this.bindParameters=new wc(r,i!=null?i.plane:null),this.bindParameters.alignPixelEnabled=!0}},tu=class extends ja{constructor(e,r,i,s){super(e,i,s),this.offscreenRenderingHelper=r,this.sliceHelper=s,this.time=mo(0)}};const xi=Re.Occlude|Re.OccludeAndTransparent|Re.OccludeAndTransparentStencil;let Bt=class extends I{constructor(){super(...arguments),this._projectionMatrix=W()}get projectionMatrix(){return this._projectionMatrix}};m([b()],Bt.prototype,"_projectionMatrix",void 0),m([b({readOnly:!0})],Bt.prototype,"projectionMatrix",null),Bt=m([tr("esri.views.3d.webgl-engine.lib.CascadeCamera")],Bt);var Ci;(function(t){t[t.Highlight=0]="Highlight",t[t.ExcludeHighlight=1]="ExcludeHighlight"})(Ci||(Ci={}));let ur=class{constructor(){this.camera=new Bt,this.lightMat=W()}},Cc=class{constructor(){this.maxNumCascadesHighQuality=4,this.maxNumCascadesLowQuality=4,this.textureSizeModHighQuality=1.3,this.textureSizeModLowQuality=.9,this.splitSchemeLambda=0}},Sc=class{constructor(e,r){this._fbos=e,this._viewingMode=r,this._enabled=!1,this._snapshots=new Array,this._textureHeight=0,this._numCascades=1,this.settings=new Cc,this._projectionView=W(),this._projectionViewInverse=W(),this._modelViewLight=W(),this._cascadeDistances=[0,0,0,0,0],this._usedCascadeDistances=Ve(),this._cascades=[new ur,new ur,new ur,new ur],this._lastOrigin=null,this._maxTextureWidth=Math.min(Dt("esri-mobile")?4096:16384,e.rctx.parameters.maxTextureSize)}dispose(){this.enabled=!1,this.disposeOffscreenBuffers()}get depthTexture(){var e;return(e=this._handle)==null?void 0:e.getTexture()}get _textureWidth(){return this._textureHeight*this._numCascades}get numCascades(){return this._numCascades}get cascadeDistances(){return fi(this._usedCascadeDistances,this._cascadeDistances[0],this._numCascades>1?this._cascadeDistances[1]:1/0,this._numCascades>2?this._cascadeDistances[2]:1/0,this._numCascades>3?this._cascadeDistances[3]:1/0)}disposeOffscreenBuffers(){this._handle=Ar(this._handle),this._discardSnapshots()}set maxCascades(e){this.settings.maxNumCascadesHighQuality=Mt(Math.floor(e),1,4)}get maxCascades(){return this.settings.maxNumCascadesHighQuality}set enabled(e){this._enabled=e,e||this.disposeOffscreenBuffers()}get enabled(){return this._enabled}get ready(){return this._enabled&&this.depthTexture!=null}get cascades(){for(let e=0;e<this._numCascades;++e)ii[e]=this._cascades[e];return ii.length=this._numCascades,ii}start(e,r,i,s,a){pe(this.enabled);const{near:o,far:n}=this._clampNearFar(i);this._computeCascadeDistances(o,n,s),this._textureHeight=this._computeTextureHeight(e,a,s),this._setupMatrices(e,r);const{viewMatrix:c,projectionMatrix:l}=e;for(let d=0;d<this._numCascades;++d)this._constructCascade(d,l,c,r);this._lastOrigin=null,this.clear()}finish(){var e;pe(this.enabled),(e=this._handle)==null||e.detachDepth()}getShadowMapMatrices(e){if(!this._lastOrigin||!St(e,this._lastOrigin)){this._lastOrigin=this._lastOrigin||E(),X(this._lastOrigin,e);for(let r=0;r<this._numCascades;++r){Qi(js,this._cascades[r].lightMat,e);for(let i=0;i<16;++i)zs[16*r+i]=js[i]}}return zs}moveSnapshot(e){var r,i;pe(this.enabled),(r=this._handle)==null||r.detachDepth(),(i=this._snapshots[e])==null||i.release(),this._snapshots[e]=this._handle,this._handle=null,this.clear()}copySnapshot(e){var c,l,d,h;const r=(l=(c=this._handle)==null?void 0:c.getTexture())==null?void 0:l.descriptor;if(!this.enabled||!r)return;(d=this._snapshots[e])==null||d.release();const{width:i,height:s}=r,a=e===Ci.Highlight?"shadow highlight snapshot":"shadow no highlight snapshot";this._snapshots[e]=this._fbos.acquire(i,s,a,Mr.RGBA4);const o=this._fbos.rctx;this._bindFbo();const n=o.bindTexture((h=this._snapshots[e])==null?void 0:h.getTexture(),Xt.TEXTURE_UNIT_FOR_UPDATES);o.gl.copyTexSubImage2D(Vn.TEXTURE_2D,0,0,0,0,0,i,s),o.bindTexture(n,Xt.TEXTURE_UNIT_FOR_UPDATES)}getSnapshot(e){var r;return this.enabled?(r=this._snapshots[e])==null?void 0:r.getTexture():null}clear(){const e=this._fbos.rctx;this._ensureFbo(),this._bindFbo(),e.setClearColor(1,1,1,1),e.clearSafe($r.COLOR_BUFFER_BIT|$r.DEPTH_BUFFER_BIT)}_computeTextureHeight(e,r,i){const s=Math.min(window.devicePixelRatio,r)/e.pixelRatio,a=i?this.settings.textureSizeModHighQuality:this.settings.textureSizeModLowQuality,o=cn(Math.floor(Math.max(e.fullWidth,e.fullHeight)*s*a)),n=Math.min(this._maxTextureWidth,this._numCascades*o);return dn(n/this._numCascades)}_ensureFbo(){var e,r,i,s;((e=this._handle)==null?void 0:e.fbo.width)===this._textureWidth&&((r=this._handle)==null?void 0:r.fbo.height)===this._textureHeight||((i=this._handle)==null||i.release(),this._handle=this._fbos.acquire(this._textureWidth,this._textureHeight,"shadow map",Mr.RGBA4)),(s=this._handle)==null||s.acquireDepth(hn.DEPTH16_BUFFER)}_discardSnapshot(e){this._snapshots[e]=Ar(this._snapshots[e])}_discardSnapshots(){for(let e=0;e<this._snapshots.length;++e)this._discardSnapshot(e);this._snapshots.length=0}_bindFbo(){var r;const e=this._fbos.rctx;e.unbindTexture(this.depthTexture),e.bindFramebuffer((r=this._handle)==null?void 0:r.fbo)}_constructCascade(e,r,i,s){const a=this._cascades[e],o=-this._cascadeDistances[e],n=-this._cascadeDistances[e+1],c=(r[10]*o+r[14])/Math.abs(r[11]*o+r[15]),l=(r[10]*n+r[14])/Math.abs(r[11]*n+r[15]);pe(c<l);for(let p=0;p<8;++p){fi(Is,p%4==0||p%4==3?-1:1,p%4==0||p%4==1?-1:1,p<4?c:l,1);const f=Ce[p];Ht(f,Is,this._projectionViewInverse),f[0]/=f[3],f[1]/=f[3],f[2]/=f[3]}go(ri,Ce[0]),a.camera.viewMatrix=Qi(Tc,this._modelViewLight,ri);for(let p=0;p<8;++p)ye(Ce[p],Ce[p],a.camera.viewMatrix);let d=Ce[0][2],h=Ce[0][2];for(let p=1;p<8;++p)d=Math.min(d,Ce[p][2]),h=Math.max(h,Ce[p][2]);d-=200,h+=200,a.camera.near=-h,a.camera.far=-d,Ac(i,s,d,h,a.camera),Be(a.lightMat,a.camera.projectionMatrix,a.camera.viewMatrix);const u=this._textureHeight;a.camera.viewport=[e*u,0,u,u]}_setupMatrices(e,r){Be(this._projectionView,e.projectionMatrix,e.viewMatrix),kt(this._projectionViewInverse,this._projectionView);const i=this._viewingMode===Oi.Global?e.eye:Q(ri,0,0,1);sa(this._modelViewLight,[0,0,0],[-r[0],-r[1],-r[2]],i)}_clampNearFar(e){let{near:r,far:i}=e;return r<2&&(r=2),i<2&&(i=2),r>=i&&(r=2,i=4),{near:r,far:i}}_computeCascadeDistances(e,r,i){const s=i?this.settings.maxNumCascadesHighQuality:this.settings.maxNumCascadesLowQuality;this._numCascades=Math.min(1+Math.floor(Tn(r/e,4)),s);const a=(r-e)/this._numCascades,o=(r/e)**(1/this._numCascades);let n=e,c=e;for(let l=0;l<this._numCascades+1;++l)this._cascadeDistances[l]=Gt(n,c,this.settings.splitSchemeLambda),n*=o,c+=a}get test(){return{cascades:this._cascades,textureHeight:this._textureHeight}}};const Tc=W(),Is=Ve(),Ce=[];for(let t=0;t<8;++t)Ce.push(Ve());const Ps=k(),Ls=k(),Rc=k(),Fs=k(),Ns=k(),ri=E(),ii=[],js=W(),zs=Ge.concat(Ge,Ge,Ge,Ge),ve=k(),ft=k(),Ye=[k(),k(),k(),k()],q=k(),si=k(),He=k(),Ut=k(),mt=k(),gt=k(),pr=k();function Oc(t,e,r,i,s,a,o,n){gi(ve,0,0);for(let S=0;S<4;++S)qe(ve,ve,t[S]);xt(ve,ve,.25),gi(ft,0,0);for(let S=4;S<8;++S)qe(ft,ft,t[S]);xt(ft,ft,.25),zt(Ye[0],t[4],t[5],.5),zt(Ye[1],t[5],t[6],.5),zt(Ye[2],t[6],t[7],.5),zt(Ye[3],t[7],t[4],.5);let c=0,l=Ji(Ye[0],ve);for(let S=1;S<4;++S){const A=Ji(Ye[S],ve);A<l&&(l=A,c=S)}Ct(q,Ye[c],t[c+4]);const d=q[0];let h,u;q[0]=-q[1],q[1]=d,Ct(si,ft,ve),ne(si,q)<0&&vo(q,q),zt(q,q,si,r),Yi(q,q),h=u=ne(Ct(He,t[0],ve),q);for(let S=1;S<8;++S){const A=ne(Ct(He,t[S],ve),q);A<h?h=A:A>u&&(u=A)}Ri(i,ve),xt(He,q,h-e),qe(i,i,He);let p=-1,f=1,y=0,x=0;for(let S=0;S<8;++S){Ct(Ut,t[S],i),Yi(Ut,Ut);const A=q[0]*Ut[1]-q[1]*Ut[0];A>0?A>p&&(p=A,y=S):A<f&&(f=A,x=S)}ht(p>0,"leftArea"),ht(f<0,"rightArea"),xt(mt,q,h),qe(mt,mt,ve),xt(gt,q,u),qe(gt,gt,ve),pr[0]=-q[1],pr[1]=q[0];const R=cr(i,t[x],gt,qe(He,gt,pr),1,s),C=cr(i,t[y],gt,He,1,a),_=cr(i,t[y],mt,qe(He,mt,pr),1,o),O=cr(i,t[x],mt,He,1,n);ht(R,"rayRay"),ht(C,"rayRay"),ht(_,"rayRay"),ht(O,"rayRay")}function F(t,e){return 3*e+t}const Vs=k();function fe(t,e){return gi(Vs,t[e],t[e+3]),Vs}const ue=k(),T=yo();function bc(t,e,r,i,s){Ct(ue,r,i),xt(ue,ue,.5),T[0]=ue[0],T[1]=ue[1],T[2]=0,T[3]=ue[1],T[4]=-ue[0],T[5]=0,T[6]=ue[0]*ue[0]+ue[1]*ue[1],T[7]=ue[0]*ue[1]-ue[1]*ue[0],T[8]=1,T[F(0,2)]=-ne(fe(T,0),t),T[F(1,2)]=-ne(fe(T,1),t);let a=ne(fe(T,0),r)+T[F(0,2)],o=ne(fe(T,1),r)+T[F(1,2)],n=ne(fe(T,0),i)+T[F(0,2)],c=ne(fe(T,1),i)+T[F(1,2)];a=-(a+n)/(o+c),T[F(0,0)]+=T[F(1,0)]*a,T[F(0,1)]+=T[F(1,1)]*a,T[F(0,2)]+=T[F(1,2)]*a,a=1/(ne(fe(T,0),r)+T[F(0,2)]),o=1/(ne(fe(T,1),r)+T[F(1,2)]),T[F(0,0)]*=a,T[F(0,1)]*=a,T[F(0,2)]*=a,T[F(1,0)]*=o,T[F(1,1)]*=o,T[F(1,2)]*=o,T[F(2,0)]=T[F(1,0)],T[F(2,1)]=T[F(1,1)],T[F(2,2)]=T[F(1,2)],T[F(1,2)]+=1,a=ne(fe(T,1),e)+T[F(1,2)],o=ne(fe(T,2),e)+T[F(2,2)],n=ne(fe(T,1),r)+T[F(1,2)],c=ne(fe(T,2),r)+T[F(2,2)],a=-.5*(a/o+n/c),T[F(1,0)]+=T[F(2,0)]*a,T[F(1,1)]+=T[F(2,1)]*a,T[F(1,2)]+=T[F(2,2)]*a,a=ne(fe(T,1),e)+T[F(1,2)],o=ne(fe(T,2),e)+T[F(2,2)],n=-o/a,T[F(1,0)]*=n,T[F(1,1)]*=n,T[F(1,2)]*=n,s[0]=T[0],s[1]=T[1],s[2]=0,s[3]=T[2],s[4]=T[3],s[5]=T[4],s[6]=0,s[7]=T[5],s[8]=0,s[9]=0,s[10]=1,s[11]=0,s[12]=T[6],s[13]=T[7],s[14]=0,s[15]=T[8]}function Ac(t,e,r,i,s){const a=1/Ce[0][3],o=1/Ce[4][3];pe(a<o);let n=a+Math.sqrt(a*o);const c=Math.sin(_o(t[2]*e[0]+t[6]*e[1]+t[10]*e[2]));n/=c,Oc(Ce,n,c,Ps,Ls,Rc,Fs,Ns),bc(Ps,Ls,Fs,Ns,s.projectionMatrix),s.projectionMatrix[10]=2/(r-i),s.projectionMatrix[14]=-(r+i)/(r-i)}let Dc=class{constructor(){this.adds=new Ae,this.removes=new Ae,this.updates=new Ae({allocator:e=>e||new Mc,deallocator:e=>(e.renderGeometry=null,e)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}get empty(){return this.adds.length===0&&this.removes.length===0&&this.updates.length===0}},Mc=class{},Ec=class{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}};var Us;function $c(t){const e=new Map,r=i=>{let s=e.get(i);return s||(s=new Ec,e.set(i,s)),s};return t.removes.forAll(i=>{ai(i)&&r(i.material).removes.push(i)}),t.adds.forAll(i=>{ai(i)&&r(i.material).adds.push(i)}),t.updates.forAll(i=>{ai(i.renderGeometry)&&r(i.renderGeometry.material).updates.push(i)}),e}function ai(t){return t.geometry.indexCount>=1}(function(t){t[t.Default=0]="Default",t[t.Screenshot=1]="Screenshot",t[t.ObjectAndLayerID=2]="ObjectAndLayerID"})(Us||(Us={}));let Ic=class{constructor(e,r){this._material=e,this._repository=r,this._map=new Map}dispose(){this._map.forEach((e,r)=>{e!=null&&this._repository.release(this._material,r)})}load(e,r,i){const s=this._material.produces.get(r);if(!s||!s(i))return null;this._map.has(i)||this._map.set(i,this._repository.acquire(this._material,r,i));const a=this._map.get(i);if(a!=null){if(a.ensureResources(e)===bn.LOADED)return a;this._repository.requestRender()}return null}},Pc=class extends un{constructor(e=E()){super(),this.origin=e,this.slicePlaneLocalOrigin=this.origin}},Vi=class{constructor(e=0,r=0){this.from=e,this.to=r}get numElements(){return this.to-this.from}};function Hs(t){const e=new Map;t.forAll(i=>e.set(i.from,i));let r=!0;for(;r;){r=!1;for(let i=0;i<t.length;++i){const s=t.data[i],a=e.get(s.to);if(!a)return;s.to=a.to,e.delete(a.from),t.removeUnordered(a),r=!0}}}let Gs=class extends Vi{constructor(e,r,i){super(r,i),this.geometry=e}get isVisible(){return this.geometry.visible}get hasHighlights(){return this.geometry.highlights!=null&&this.isVisible}get hasOccludees(){return this.geometry.occludees!=null}};class Lc{constructor(){this.first=0,this.count=0}}let Fc=class{constructor(){this._numElements=0,this._instances=new Map,this.holes=new Ae({allocator:e=>e||new Vi,deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!0,this.drawCommandsDefault=fr(),this.drawCommandsHighlight=fr(),this.drawCommandsOccludees=fr(),this.drawCommandsShadowHighlightRest=fr()}get numElements(){return this._numElements}get instances(){return this._instances}addInstance(e,r){this.deleteInstance(e),this._instances.set(e,r),this._numElements+=r.numElements}deleteInstance(e){const r=this._instances.get(e);r&&(this._numElements-=r.numElements,this._instances.delete(e))}updateInstance(e,r,i){const s=this._instances.get(e);s&&(this._numElements-=s.numElements,s.from=r,s.to=i,this._numElements+=s.numElements)}updateDrawState(e){e.isVisible?(e.hasHighlights&&(this.hasHighlights=!0),e.hasOccludees&&(this.hasOccludees=!0)):this.hasHiddenInstances=!0}updateDrawCommands(e){if(this.drawCommandsDefault.clear(),this.drawCommandsHighlight.clear(),this.drawCommandsOccludees.clear(),this.drawCommandsShadowHighlightRest.clear(),this.drawCommandsDirty=!1,this._instances.size===0)return;if(!this.needsMultipleCommands()){const i=this.drawCommandsDefault.pushNew(),s=this.holes.front();return this.vao!=null&&this.holes.length===1&&s.to===Math.floor(this.vao.byteSize/e)?(i.first=0,void(i.count=s.from)):(i.first=1/0,i.count=0,this._instances.forEach(a=>{i.first=Math.min(i.first,a.from),i.count=Math.max(i.count,a.to)}),void(i.count-=i.first))}const r=Array.from(this._instances.values()).sort((i,s)=>i.from===s.from?i.to-s.to:i.from-s.from);for(const i of r)i.isVisible&&(Ws(i.hasOccludees?this.drawCommandsOccludees:this.drawCommandsDefault,i),Ws(i.hasHighlights?this.drawCommandsHighlight:this.drawCommandsShadowHighlightRest,i))}needsMultipleCommands(){return this.hasOccludees||this.hasHighlights||this.hasHiddenInstances}};function Nc(t){return t.vao!=null}function fr(){return new Ae({allocator:t=>t||new Lc,deallocator:t=>t})}function Ws(t,e){const r=t.back();if(r==null){const i=t.pushNew();return i.first=e.from,void(i.count=e.numElements)}if(jc(r,e)){const i=e.from-r.first+e.numElements;r.count=i}else{const i=t.pushNew();i.first=e.from,i.count=e.numElements}}function jc(t,e){return t.first+t.count>=e.from}let zc=class{constructor(e){this.origin=e,this.buffers=new Array}dispose(){this.buffers.forEach(e=>e.vao.dispose()),this.buffers.length=0}findBuffer(e){return this.buffers.find(r=>r.instances.has(e))}},Vc=class{constructor(e,r){this._cache=e(r,(i,s,a)=>this._remove(i,s,a))}hitrate(){return this._cache.hitRate}destroy(){this._cache.destroy()}clear(){this._cache.clear()}getSize(e){return this._cache.getSize(e)}pop(e){const r=this._cache.peek(e);if(!r)return;const i=r.pop();if(r.length>0){if(i){const s=this._cache.getSize(e)-Math.round(i.usedMemory);this._cache.updateSize(e,r,s)}}else this._cache.pop(e);return i}put(e,r,i=wo){const s=this._cache.peek(e);if(!s)return void this._cache.put(e,[r],r.usedMemory,i);s.push(r);const a=this._cache.getSize(e)+Math.round(r.usedMemory);this._cache.updateSize(e,s,a)}_remove(e,r,i){switch(r){case Xi.ALL:return e.forEach(s=>s.dispose()),0;case Xi.SOME:{const s=e.shift();return s&&(i-=Math.round(s.usedMemory),s.dispose()),i}}}},Uc=class{constructor(e,r,i){this._rctx=e,this._locations=r,this._layout=i,this._cache=new Vc(e.newCache,"VAOCache")}dispose(){this._cache.destroy()}newVao(e){const r=e.toString();let i=this._cache.pop(r);return i||(i=new ll(this._rctx,this._locations,{geometry:this._layout},{geometry:Jn.createVertex(this._rctx,Un.STATIC_DRAW)}),i.vertexBuffers.geometry.setSize(e),i)}deleteVao(e){if(e==null)return;const r=e.byteSize.toString();this._cache.put(r,e)}},Cr=class extends pn{constructor(t){super(t),this._vaoCache=null,this._glMaterials=null,this._bufferWriter=null,this._dataByOrigin=new Map,this._hasHighlights=!1,this._hasOccludees=!1,this._produces=new Map,this.drapedPriority=0}destroy(){this._glMaterials=Yt(this._glMaterials),this._dataByOrigin.forEach(t=>t.dispose()),this._dataByOrigin.clear(),this._vaoCache=Yt(this._vaoCache)}initialize(){this.material.produces.forEach((t,e)=>{this._produces.set(e,r=>!(this._dataByOrigin.size===0||!(r!==M.Highlight&&r!==M.ShadowHighlight||this._hasHighlights))&&t(r))})}get produces(){return this._produces}initializeRenderContext(t,e){const{rctx:r}=t.renderContext;this._glMaterials=new Ic(this.material,e??t.materialRepository),this._bufferWriter=this.material.createBufferWriter(),this._vaoCache=new Uc(r,this.material.vertexAttributeLocations,Zn(this._bufferWriter.vertexBufferLayout))}uninitializeRenderContext(){}get hasOccludees(){return this._hasOccludees}get isDecoration(){return this.material.parameters.isDecoration}queryRenderOccludedState(t){return this.material.queryRenderOccludedState(t)}get materialReference(){return this.material}get numGeometries(){let t=0;return this._dataByOrigin.forEach(e=>t+=e.buffers.reduce((r,i)=>r+i.instances.size,0)),t}get usedMemory(){let t=0;return this._dataByOrigin.forEach(e=>t+=e.buffers.reduce((r,i)=>r+i.vao.usedMemory,0)),t}forEachGeometry(t){this._dataByOrigin.forEach(e=>e.buffers.forEach(r=>r.instances.forEach(i=>t(i.geometry))))}modify(t){this._updateGeometries(t.updates),this._addAndRemoveGeometries(t.adds,t.removes),this._updateDrawCommands()}_updateGeometries(t){const e=this._bufferWriter;if(e===null)return;const r=e.vertexBufferLayout.stride/4;for(const i of t){const s=i.renderGeometry,a=this._dataByOrigin.get(s.localOrigin.id),o=a==null?void 0:a.findBuffer(s.id);if(o==null)return;const n=o.instances.get(s.id);if(i.updateType&(Ie.GEOMETRY|Ie.TRANSFORMATION)){const c=_r(e.elementCount(n.geometry.geometry)*r),l=e.vertexBufferLayout.createView(c.buffer);this._writeGeometry(s,l,0),o.vao.vertexBuffers.geometry.setSubData(c,n.from*r,0,n.numElements*r)}i.updateType&(Ie.HIGHLIGHT|Ie.OCCLUDEE|Ie.VISIBILITY)&&(o.drawCommandsDirty=!0)}}_computeDeltas(t,e){const r=new Fi;for(const i of t){const s=i.localOrigin;if(s==null)continue;let a=r.get(s.id,null);a==null&&(a=new Bs(s.vec3),r.set(s.id,null,a)),a.changes.push(i)}for(const i of e){const s=i.localOrigin;if(s==null)continue;const a=this._dataByOrigin.get(s.id),o=a==null?void 0:a.findBuffer(i.id);if(o==null)continue;let n=r.get(s.id,o);n==null&&(n=new Bs(s.vec3),r.set(s.id,o,n)),n.changes.push(i)}return r}_addAndRemoveGeometries(t,e){if(this._bufferWriter===null||this._vaoCache===null)return;const{_bufferWriter:r,_dataByOrigin:i}=this,s=r.vertexBufferLayout.stride/4,a=this._computeDeltas(t,e);a.forEach((o,n)=>{const c=o.get(null),l=c!=null?c.changes:[];a.delete(n,null);let d=i.get(n);if(o.forEach((h,u)=>{if(a.delete(n,u),u==null)return void pe(!1,"No VAO for removed geometries");if(u.instances.size===h.changes.length)return this._vaoCache.deleteVao(u.vao),Ki(d.buffers,u),void(d.buffers.length===0&&l.length===0&&i.delete(n));const p=u.numElements,f=u.vao.byteSize/4,y=l.reduce((_,O)=>_+r.elementCount(O.geometry),0),x=h.changes.reduce((_,O)=>_+r.elementCount(O.geometry),0),R=Math.min((p+y-x)*s,gr),C=R>f;R>Nr&&R<f/2?(h.changes.forEach(({id:_})=>u.deleteInstance(_)),u.instances.forEach(({geometry:_})=>l.push(_)),this._vaoCache.deleteVao(u.vao),Ki(d.buffers,u)):C?this._applyAndRebuild(u,l,h):this._applyRemoves(u,h)}),l.length>0)for(d==null&&(d=new zc(c.origin),i.set(n,d)),d.buffers.forEach(h=>this._applyAdds(h,l));l.length>0;)d.buffers.push(this._applyAndRebuild(new Fc,l,null))})}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach(t=>{t.buffers.forEach(e=>{e.drawCommandsDirty&&(e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,Wt(e.instances,r=>(e.updateDrawState(r),e.hasHiddenInstances&&e.hasHighlights&&e.hasOccludees)),e.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)),this._hasHighlights=this._hasHighlights||e.hasHighlights,this._hasOccludees=this._hasOccludees||e.hasOccludees})})}_applyAndRebuild(t,e,r){if(r!=null)for(const p of r.changes)t.deleteInstance(p.id);const i=this._bufferWriter,s=i.vertexBufferLayout.stride,a=s/4,o=Math.floor(gr/a);let n=t.numElements;for(;e.length>0;){const p=e.pop(),f=i.elementCount(p.geometry);if(n+f>o&&n>0){e.push(p);break}n+=f;const y=new Gs(p,0,0);pe(t.instances.get(p.id)==null),t.addInstance(p.id,y)}const c=n*a,l=_r(c),d=i.vertexBufferLayout.createView(l.buffer);let h=0;t.hasHiddenInstances=!1,t.hasHighlights=!1,t.hasOccludees=!1,t.instances.forEach((p,f)=>{this._writeGeometry(p.geometry,d,h);const y=h;h+=i.elementCount(p.geometry.geometry),t.updateInstance(f,y,h),t.updateDrawState(p)}),this._vaoCache.deleteVao(t.vao),t.vao=this._vaoCache.newVao(Zs(c)),t.vao.vertexBuffers.geometry.setSubData(l,0,0,h*a),t.holes.clear();const u=t.holes.pushNew();return u.from=h,u.to=Math.floor(t.vao.byteSize/s),t.updateDrawCommands(s),t}_applyRemoves(t,e){if(e.changes.length===0||this._bufferWriter===null)return;for(const o of e.changes){const n=o.id,c=t.instances.get(n);if(!c)continue;t.deleteInstance(n);const l=$e.back();if(l){if(l.to===c.from){l.to=c.to;continue}if(l.from===c.to){l.from=c.from;continue}}const d=$e.pushNew();d.from=c.from,d.to=c.to}Hs($e);const r=this._bufferWriter.vertexBufferLayout.stride/4,i=$e.reduce((o,n)=>Math.max(o,n.numElements),0)*r,s=_r(i);s.fill(0,0,i);const a=t.vao.vertexBuffers.geometry;$e.forAll(o=>a.setSubData(s,o.from*r,0,o.numElements*r)),t.holes.pushArray($e.data,$e.length),$e.forAll((o,n)=>$e.data[n]=null),$e.clear(),t.drawCommandsDirty=!0}_applyAdds(t,e){if(e.length===0||this._bufferWriter===null)return;if(!Nc(t))return void this._applyAndRebuild(t,e,null);const r=this._bufferWriter,i=r.vertexBufferLayout.stride/4,s=t.numElements,a=e.reduce((x,R)=>x+r.elementCount(R.geometry),0),o=Math.min((s+a)*i,gr),n=4*o;if(t.vao.byteSize<Zs(gr-Nr)&&n>t.vao.byteSize)return void this._applyAndRebuild(t,e,null);Hs(t.holes);const c=new Array;for(const x of e){const R=r.elementCount(x.geometry),C=Hc(t.holes,R);c.push(C)}const l=t.vao.vertexBuffers.geometry;let d=0,h=0,u=0;const p=_r(o),f=r.vertexBufferLayout.createView(p.buffer);e.forEach((x,R)=>{const C=c[R];if(C==null)return;if(u!==C){const S=u-h;S>0&&l.setSubData(p,h*i,0,S*i),h=C,d=0}const _=r.elementCount(x.geometry);this._writeGeometry(x,f,d),d+=_,u=C+_;const O=new Gs(x,C,C+_);pe(t.instances.get(x.id)==null),t.addInstance(x.id,O),t.drawCommandsDirty=!0});const y=u-h;y>0&&l.setSubData(p,h*i,0,y*i),xo(e,(x,R)=>c[R]==null)}_writeGeometry(t,e,r){if(this._bufferWriter===null)return;const i=t.localOrigin.vec3;Rn(ks,-i[0],-i[1],-i[2]);const s=Be(Gc,ks,t.transformation);kt(mr,s),ia(mr,mr),this._bufferWriter.write(s,mr,t.geometry,e,r)}updateAnimation(t){return this.material.update(t)}prepareTechnique(t){if(!this.material.shouldRender(t))return null;const{output:e,bindParameters:r}=t,i=this.material.produces.get(r.slot);if(!i||!i(e))return null;const s=e===M.Highlight||e===M.ShadowHighlight;if(s&&!this._hasHighlights)return null;const a=e===M.ShadowExcludeHighlight,o=!(s||a);for(const n of this._dataByOrigin.values())for(const c of n.buffers){if(s&&!c.hasHighlights)continue;const l=(s?c.drawCommandsHighlight:a&&c.needsMultipleCommands()?c.drawCommandsShadowHighlightRest:c.drawCommandsDefault)||null,d=o&&c.drawCommandsOccludees||null;if(l!=null&&l.length||d!=null&&d.length){const h=this._glMaterials.load(t.rctx,r.slot,e),u=h!=null?h.beginSlot(r):null;if(u!=null)return u}}return null}renderNode(t,e){const{output:r,bindParameters:i}=t,s=r===M.Highlight||r===M.ShadowHighlight,a=r===M.ShadowExcludeHighlight,o=!(s||a),n=t.rctx,c=t.bindParameters.slot===ie.OCCLUDER_MATERIAL,l=t.bindParameters.slot===ie.TRANSPARENT_OCCLUDER_MATERIAL;n.runAppleAmdDriverHelper(),n.bindTechnique(e,i,this.material.parameters);for(const d of this._dataByOrigin.values())for(const h of d.buffers){if(s&&!h.hasHighlights)continue;const u=(s?h.drawCommandsHighlight:a&&h.needsMultipleCommands()?h.drawCommandsShadowHighlightRest:h.drawCommandsDefault)||null,p=o&&h.drawCommandsOccludees||null;(u!=null&&u.length||p!=null&&p.length)&&(e.program.bindDraw(new Pc(d.origin),i,this.material.parameters),e.ensureAttributeLocations(h.vao),n.bindVAO(h.vao),u!=null&&u.length&&(n.setPipelineState(e.getPipeline(!1,c,l)),u.forAll(f=>n.drawArrays(e.primitiveType,f.first,f.count))),p!=null&&p.length&&(n.setPipelineState(e.getPipeline(!0,c,l)),p.forAll(f=>n.drawArrays(e.primitiveType,f.first,f.count))))}}get test(){return{material:this.material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}};m([b({constructOnly:!0})],Cr.prototype,"material",void 0),Cr=m([tr("esri.views.3d.webgl-engine.materials.renderers.MergedRenderer")],Cr);class Bs{constructor(e){this.origin=e,this.changes=new Array}}function Hc(t,e){let r;if(!t.some(s=>!(s.numElements<e)&&(r=s,!0)))return null;const i=r.from;return r.from+=e,r.from>=r.to&&t.removeUnordered(r),i}const ks=W(),Gc=W(),mr=W(),$e=new Ae({allocator:t=>t||new Vi,deallocator:null}),Nr=65536,oi=4*Nr,qs=1024,za=16777216,gr=za/4;let ni=new Float32Array(Nr);function _r(t){return ni.length<t&&(ni=new Float32Array(t)),ni}function Zs(t){const e=4*t;return e<=qs?qs:e<oi?Co(e):Math.max(Math.min(Math.ceil(1.5*e/oi)*oi,za),e)}let xe=class extends ra{constructor(e){super(e),this._pending=new Wc,this._changes=new Dc,this._materialRenderers=new Ae,this._sortedMaterialRenderers=new Ae,this._geometries=new Map,this._hasHighlights=!1,this._hasWater=!1}destroy(){this._changes.prune(),this._materialRenderers.forAll(e=>e.destroy()),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear(),this._geometries.clear(),this._pending.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get rctx(){return this.rendererContext.rctx}get _materialRepository(){return this.rendererContext.materialRepository}get _localOriginFactory(){return this.rendererContext.localOriginFactory}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccludedDraped(){return this._materialRenderers.some(e=>e.numGeometries!==0&&!e.queryRenderOccludedState(Re.Occlude))}get isEmpty(){return!this.updating&&this._materialRenderers.length===0&&this._geometries.size===0}getMemoryForMaterial(e){if(e==null)return 0;const r=this._materialRenderers.find(i=>i.materialReference===e);return(r==null?void 0:r.usedMemory)??0}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const e=$c(this._changes);let r=!1;return e.forEach((i,s)=>{let a=this._materialRenderers.find(o=>o.materialReference===s);if(!a&&i.adds.length>0){const o=new Cr({material:s});o.initializeRenderContext(this.rendererContext.pluginContext,this._materialRepository),a=o,this._materialRenderers.push(a),r=!0}a&&(a.modify(i),a.numGeometries===0&&(this._materialRenderers.removeUnordered(a),a.destroy(),r=!0))}),this._changes.clear(),r&&this._updateSortedMaterialRenderers(),this._hasHighlights=this._materialRenderers.some(i=>{const s=i.produces.get(ie.DRAPED_MATERIAL);return!!s&&s(M.Highlight)}),this._hasWater=this._materialRenderers.some(i=>{const s=i.produces.get(ie.DRAPED_WATER);return!!s&&s(M.Normal)}),this.notifyChange("updating"),!0}addGeometries(e,r){if(e.length===0)return;const i=this._validateRenderGeometries(e);for(const a of i)this._geometries.set(a.id,a);const s=this._pending.empty;for(const a of i)this._pending.adds.add(a);s&&this.notifyChange("updating"),r===Pr.UPDATE&&this._notifyGraphicGeometryChanged(e)}removeGeometries(e,r){const i=this._pending.empty,s=this._pending.adds;for(const a of e)s.has(a)?(this._pending.removed.add(a),s.delete(a)):this._pending.removed.has(a)||this._pending.removes.add(a),this._geometries.delete(a.id);i&&!this._pending.empty&&this.notifyChange("updating"),r===Pr.UPDATE&&this._notifyGraphicGeometryChanged(e)}modifyGeometries(e,r){const i=this._changes.updates.length===0;for(const s of e){const a=this._changes.updates.pushNew();a.renderGeometry=this._validateRenderGeometry(s),a.updateType=r}switch(i&&this._changes.updates.length>0&&this.notifyChange("updating"),r){case Ie.TRANSFORMATION:case Ie.GEOMETRY:return this._notifyGraphicGeometryChanged(e);case Ie.VISIBILITY:return this._notifyGraphicVisibilityChanged(e)}}updateAnimation(e){let r=!1;return this._sortedMaterialRenderers.forAll(i=>r=!!i.updateAnimation&&i.updateAnimation(e)||r),r}shouldRender(e){return this._sortedMaterialRenderers.some(r=>r.prepareTechnique(e))}render(e){this._sortedMaterialRenderers.forAll(r=>{const i=r.prepareTechnique(e);i!=null&&r.renderNode(e,i)})}intersect(e,r,i,s,a){return this._geometries.forEach(o=>{if(s&&!s(o))return;this._intersectRenderGeometry(o,i,r,0,e,a);const n=this.rendererContext.longitudeCyclical;n&&(o.boundingSphere[0]-o.boundingSphere[3]<n.min&&this._intersectRenderGeometry(o,i,r,n.range,e,a),o.boundingSphere[0]+o.boundingSphere[3]>n.max&&this._intersectRenderGeometry(o,i,r,-n.range,e,a)),a++}),a}_updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear(),this._materialRenderers.forAll((e,r)=>{e.drapedPriority=r,this._sortedMaterialRenderers.push(e)}),this._sortedMaterialRenderers.sort((e,r)=>{var i,s,a,o;return((i=r.materialReference)==null?void 0:i.renderPriority)===((s=e.materialReference)==null?void 0:s.renderPriority)?e.drapedPriority-r.drapedPriority:(((a=r.materialReference)==null?void 0:a.renderPriority)||0)-(((o=e.materialReference)==null?void 0:o.renderPriority)||0)})}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let e=0;e<this._changes.updates.length;){const r=this._changes.updates.data[e];this._pending.has(r.renderGeometry)?this._changes.updates.removeUnorderedIndex(e):e++}this._pending.clear()}_intersectRenderGeometry(e,r,i,s,a,o){if(!e.visible)return;let n=0;s+=e.transformation[12],n=e.transformation[13],li[0]=i[0]-s,li[1]=i[1]-n,e.screenToWorldRatio=this.rendererContext.screenToWorldRatio,e.material.intersectDraped(e,null,a,li,(c,l,d)=>{Bc(r,d,o,e.material.renderPriority,a,e.layerUid,e.graphicUid)},r)}_notifyGraphicGeometryChanged(e){if(this.drapeSource.notifyGraphicGeometryChanged==null)return;let r;for(const i of e){const s=i.graphicUid;s!=null&&s!==r&&(this.drapeSource.notifyGraphicGeometryChanged(s),r=s)}}_notifyGraphicVisibilityChanged(e){if(this.drapeSource.notifyGraphicVisibilityChanged==null)return;let r;for(const i of e){const s=i.graphicUid;s!=null&&s!==r&&(this.drapeSource.notifyGraphicVisibilityChanged(s),r=s)}}_validateRenderGeometries(e){for(const r of e)this._validateRenderGeometry(r);return e}_validateRenderGeometry(e){return e.localOrigin==null&&(e.localOrigin=this._localOriginFactory.getOrigin(br(e.boundingSphere))),e}get test(){return{sortedMaterialRenderers:this._sortedMaterialRenderers}}};m([b()],xe.prototype,"drapeSource",void 0),m([b()],xe.prototype,"updating",null),m([b()],xe.prototype,"rctx",null),m([b({constructOnly:!0})],xe.prototype,"rendererContext",void 0),m([b()],xe.prototype,"_materialRepository",null),m([b()],xe.prototype,"_localOriginFactory",null),m([b({readOnly:!0})],xe.prototype,"isEmpty",null),m([b()],xe.prototype,"_materialRenderers",void 0),m([b()],xe.prototype,"_geometries",void 0),xe=m([tr("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],xe);let Wc=class{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return this.adds.size===0&&this.removes.size===0&&this.removed.size===0}has(e){return this.adds.has(e)||this.removes.has(e)||this.removed.has(e)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}};function Bc(t,e,r,i,s,a,o){const n=new Gn(a,o,e),c=l=>{l.set(Bn.OVERLAY,n,t.dist,t.normal,t.transformation,r,i)};if((s.results.min.drapedLayerOrder==null||r>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||s.results.ground.dist<=s.results.min.dist)&&c(s.results.min),s.options.store!==ms.MIN&&(s.results.max.drapedLayerOrder==null||r<s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||s.results.ground.dist>s.results.max.dist)&&c(s.results.max),s.options.store===ms.ALL){const l=Wn(s.ray);c(l),s.results.all.push(l)}}const li=k();let Va=class Ua extends Ii{initializeProgram(e){return new Pi(e.rctx,Ua.shader.get().build(),aa)}initializePipeline(){return this.configuration.hasAlpha?tt({blending:jn(Ot.SRC_ALPHA,Ot.ONE,Ot.ONE_MINUS_SRC_ALPHA,Ot.ONE_MINUS_SRC_ALPHA),colorWrite:Et}):tt({colorWrite:Et})}};Va.shader=new Li(Ml,()=>Ai(()=>import("./ColorMaterial.glsl-9YKbkIUs.js").then(t=>t.T),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23])));class Ha extends pa{constructor(){super(...arguments),this.hasAlpha=!1}}m([P()],Ha.prototype,"hasAlpha",void 0);let Ga=class extends ha{constructor(){super(...arguments),this.overlayIndex=be.INNER,this.opacity=1}};function kc(){const t=new Ei;return t.include(ca),t.fragment.uniforms.add(new ke("tex",e=>e.texture)),t.fragment.uniforms.add(new fn("overlayIdx",e=>e.overlayIndex)),t.fragment.uniforms.add(new Z("opacity",e=>e.opacity)),t.fragment.code.add(w`void main() {
vec2 overlayUV = overlayIdx == 0 ? vec2(uv.x * 0.5, uv.y) : vec2(uv.x * 0.5 + 0.5, uv.y);
fragColor = texture(tex, overlayUV) * opacity;
}`),t}const qc=Object.freeze(Object.defineProperty({__proto__:null,OverlayCompositingPassParameters:Ga,build:kc},Symbol.toStringTag,{value:"Module"}));let Wa=class Ba extends Ii{initializeProgram(e){return new Pi(e.rctx,Ba.shader.get().build(),aa)}initializePipeline(){return tt({blending:zn(Ot.ONE,Ot.ONE_MINUS_SRC_ALPHA),colorWrite:Et})}};Wa.shader=new Li(qc,()=>Ai(()=>import("./ColorMaterial.glsl-9YKbkIUs.js").then(t=>t.O),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23])));let Te=class extends mn{constructor(e){super(e),this._overlays=null,this._renderTargets=null,this._overlayParameters=new Ga,this.hasHighlights=!1,this._hasWater=!1,this._renderers=new Map,this._sortedDrapeSourceRenderersDirty=!1,this._sortedRenderers=new Ae,this._passParameters=new xa,this._materialRepository=null,this._screenToWorldRatio=1,this._localOriginFactory=null,this.unloadedMemory=0,this.ignoresMemoryFactor=!1,this._camera=new I,this.worldToPCSRatio=1,this.events=new ea,this.longitudeCyclical=null,this.produces=new Map([[ie.DRAPED_MATERIAL,r=>r!==M.Highlight||this.hasHighlights],[ie.DRAPED_WATER,()=>this._hasWater]]),this._hasTargetWithoutRasterImage=!1,this._hasDrapedFeatureSource=!1,this._hasDrapedRasterSource=!1}initialize(){const e=this.view._stage.renderer.fboCache,r=this.view._stage.renderView,{waterTextures:i,stippleTextures:s,markerTextures:a}=r;this._shaderTechniques=new El({rctx:this._rctx,viewingMode:Oi.Local,stippleTextureRepository:s,markerTextureRepository:a,waterTextureRepository:i}),this._renderContext=new ja(this._rctx,new Sc(e,this.view.state.viewingMode),null),this.addHandles([Ur(()=>i.updating,()=>this.events.emit("content-changed"),es),Ur(()=>this.spatialReference,o=>this._localOriginFactory=new vc(o),es),So(()=>this.view.allLayerViews,"after-changes",()=>this._sortedDrapeSourceRenderersDirty=!0)]),this._materialRepository=new jl(r.textureRepository,this._shaderTechniques,()=>{this.notifyChange("rendersOccludedDraped"),this.events.emit("content-changed"),this.notifyChange("updating"),this.notifyChange("isEmpty")},()=>this.events.emit("content-changed")),this._bindParameters.slot=ie.DRAPED_MATERIAL,this._bindParameters.mainDepth=null,this._camera.near=1,this._camera.far=1e4,this._camera.relativeElevation=null,this._bindParameters.camera=this._camera,this._bindParameters.transparencyPassType=Ue.NONE,this._bindParameters.newLighting.noonFactor=0,this._bindParameters.newLighting.globalFactor=0,this._bindParameters.newLighting.set([new gn(st(1,1,1))]),this.addHandles(this.view.resourceController.scheduler.registerTask(Yn.STAGE,this))}destroy(){this._renderers.forEach(e=>e.destroy()),this._renderers.clear(),this._debugTextureTechnique=Ar(this._debugTextureTechnique),this._passParameters.texture=Yt(this._passParameters.texture),this._shaderTechniques=ta(this._shaderTechniques),this.disposeOverlays()}get _bindParameters(){return this._renderContext.bindParameters}get _rctx(){return this.view._stage.renderView.renderingContext}get rctx(){return this._rctx}get materialRepository(){return this._materialRepository}get screenToWorldRatio(){return this._screenToWorldRatio}get localOriginFactory(){return this._localOriginFactory}initializeRenderContext(e){this.pluginContext=e}uninitializeRenderContext(){}renderNode(){}get updating(){return this._sortedDrapeSourceRenderersDirty||Wt(this._renderers,e=>e.updating)}get hasOverlays(){return this._overlays!=null&&this._renderTargets!=null}getMemoryForMaterial(e){return Array.from(this._renderers.values()).reduce((r,i)=>r+i.getMemoryForMaterial(e),0)}get layers(){return this._sortedDrapeSourceRenderersDirty&&this._updateSortedDrapeSourceRenderers(),this._sortedRenderers.map(e=>e.drapeSource.layer).filter(e=>!!e)}createGeometryDrapeSourceRenderer(e){return this.createDrapeSourceRenderer(e,xe)}createDrapeSourceRenderer(e,r,i){const s=this._renderers.get(e);s!=null&&s.destroy();const a=new r({...i,rendererContext:this,drapeSource:e});return this._renderers.set(e,a),this._sortedDrapeSourceRenderersDirty=!0,"fullOpacity"in e&&this.addHandles(Ur(()=>e.fullOpacity,()=>this.events.emit("content-changed")),e),a}removeDrapeSourceRenderer(e){if(e==null)return;const r=this._renderers.get(e);r!=null&&(this._sortedDrapeSourceRenderersDirty=!0,this._renderers.delete(e),this.removeHandles(e),r.destroy())}computeValidity(){var e;return((e=this._renderTargets)==null?void 0:e.computeValidity())??0}releaseRenderTargets(){var e;(e=this._renderTargets)==null||e.dispose()}get overlays(){return this._overlays??[]}ensureDrapeTargets(e){this._hasTargetWithoutRasterImage=!!this._overlays&&Hr(e,r=>r.drapeTargetType===_i.WithoutRasterImage)}ensureDrapeSources(e){this._overlays?(this._hasDrapedFeatureSource=Hr(e,r=>r.drapeSourceType===qt.Features),this._hasDrapedRasterSource=Hr(e,r=>r.drapeSourceType===qt.RasterImage)):this._hasDrapedFeatureSource=this._hasDrapedRasterSource=!1}get _needsColorWithoutRasterImage(){return this._hasDrapedRasterSource&&this._hasDrapedFeatureSource&&this._hasTargetWithoutRasterImage}ensureOverlays(e,r,i=this._bindParameters.overlayStretch){this._overlays==null&&(this._renderTargets=new ul(this.view._stage.renderer.fboCache),this._overlays=[new Cs,new Cs]),this.ensureDrapeTargets(e),this.ensureDrapeSources(r),this._bindParameters.overlayStretch=i}disposeOverlays(){this._overlays=null,this._renderTargets=Yt(this._renderTargets),this.events.emit("textures-disposed")}getTexture(e){var r,i;if(e!=null)return e===Y.ColorNoRasterImage&&!this._needsColorWithoutRasterImage&&this._hasDrapedFeatureSource?(r=this._renderTargets)==null?void 0:r.getTexture(Y.Color):(i=this._renderTargets)==null?void 0:i.getTexture(e)}get running(){return this.updating}runTask(e){this._processDrapeSources(e,()=>!0)}_processDrapeSources(e,r){let i=!1;for(const[s,a]of this._renderers){if(e.done)break;(s.destroyed||r(s))&&a.commitChanges()&&(i=!0,e.madeProgress())}this._sortedDrapeSourceRenderersDirty&&(this._sortedDrapeSourceRenderersDirty=!1,i=!0,this._updateSortedDrapeSourceRenderers()),i&&(this._overlays!=null&&this._renderers.size===0&&this.disposeOverlays(),this.notifyChange("updating"),this.notifyChange("isEmpty"),this.events.emit("content-changed"),this.hasHighlights=Wt(this._renderers,s=>s.hasHighlights),this.notifyChange("rendersOccludedDraped"),this._updateHasWater())}processSyncDrapeSources(){this._processDrapeSources(Xn,e=>e.updatePolicy===Kt.SYNC)}get isEmpty(){return!Gr.OVERLAY_DRAW_DEBUG_TEXTURE&&!Wt(this._renderers,e=>!e.isEmpty)}get hasWater(){return this._hasWater}get rendersOccludedDraped(){const e=this._renderContext.renderOccludedMask;this._renderContext.renderOccludedMask=Qs;const r=this._sortedRenderers.some(({renderer:i})=>i.shouldRender(this._renderContext));return this._renderContext.renderOccludedMask=e,r}renders(e){return Gr.OVERLAY_DRAW_DEBUG_TEXTURE&&e!==Y.Occluded||this._sortedRenderers.some(({renderer:r})=>r.shouldRender(this._renderContext))}get mode(){var e,r;return this.isEmpty?bt.Disabled:(e=this._renderTargets)!=null&&e.getTexture(Y.WaterNormal)?bt.EnabledWithWater:(r=this._renderTargets)!=null&&r.getTexture(Y.Color)?bt.Enabled:bt.Disabled}updateAnimation(e){let r=!1;return this._renderers.forEach(i=>r=i.updateAnimation(e)||r),r}updateDrapeSourceOrder(){this._sortedDrapeSourceRenderersDirty=!0}drawOverlays(e){if(this._overlays&&this._renderTargets){for(const r of this._overlays)this.longitudeCyclical?r.setupGeometryViewsCyclical(this.longitudeCyclical):r.setupGeometryViewsDirect();for(const r of this._renderTargets.targets){if(r.content===Y.ColorNoRasterImage&&!this._needsColorWithoutRasterImage)continue;const i=this._drawTarget(be.INNER,r,e),s=this._drawTarget(be.OUTER,r,e);(i||s)&&r.fbo.generateMipMap()}}}_drawTarget(e,r,i){const s=this._overlays[e],a=s.canvasGeometries;if(a.numViews===0)return!1;const{alignPixelEnabled:o,contentPixelRatio:n}=i;this._screenToWorldRatio=n*s.mapUnitsPerPixel/this._bindParameters.overlayStretch;const c=r.output;if(this.isEmpty||c===M.Highlight&&!this.hasHighlights||c===M.Normal&&!this.hasWater||!s.hasSomeSizedView())return!1;const l=this._rctx;if(this._camera.pixelRatio=s.pixelRatio*n,this._renderContext.output=c,this._bindParameters.alignPixelEnabled=o,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=c===M.Normal?ie.DRAPED_WATER:ie.DRAPED_MATERIAL,r.content===Y.Occluded&&(this._renderContext.renderOccludedMask=Qs),!this.renders(r.content))return this._renderContext.renderOccludedMask=xi,!1;const d=s.resolution;this._rctx.setViewport(e===be.INNER?0:d,0,d,d);const h=2*s.resolution,u=s.resolution,p=r.fbo;if(p.bind(l,h,u),e===be.INNER&&(l.setClearColor(0,0,0,0),l.clearSafe($r.COLOR_BUFFER_BIT)),Gr.OVERLAY_DRAW_DEBUG_TEXTURE&&r.content!==Y.Occluded)for(let f=0;f<a.numViews;f++)this._setViewParameters(a.extents[f],s),this._ensureDebugPatternResources(s.resolution,Qc[e]),this._rctx.bindTechnique(this._debugTextureTechnique,this._renderContext.bindParameters,this._passParameters),this._rctx.screen.draw();return this._sortedRenderers.forAll(({drapeSource:f,renderer:y})=>{if(r.content===Y.ColorNoRasterImage&&f.drapeSourceType===qt.RasterImage)return;const{fullOpacity:x}=f,R=x!=null&&x<1&&c===M.Color?this.bindTemporaryFramebuffer(h,u):null;for(let C=0;C<a.numViews;C++)this._setViewParameters(a.extents[C],s),y.render(this._renderContext);if(R){p.bind(l,h,u),this._overlayParameters.texture=R.getTexture(),this._overlayParameters.opacity=x,this._overlayParameters.overlayIndex=e;const C=this.pluginContext.techniqueRepository.acquire(Wa);this._rctx.bindTechnique(C,this._renderContext.bindParameters,this._overlayParameters),this._rctx.screen.draw(),C.release(),R.release()}}),l.bindFramebuffer(null),this._renderContext.renderOccludedMask=xi,!0}bindTemporaryFramebuffer(e,r){const i=this.view._stage.renderer.fboCache,s=i.acquire(e,r,"overlay tmp");return i.rctx.unbindTexture(s.fbo.colorTexture),i.rctx.bindFramebuffer(s.fbo),i.rctx.clearSafe($r.COLOR_BUFFER_BIT),s}async reloadShaders(){await this._shaderTechniques.reloadAll()}notifyContentChanged(){this.events.emit("content-changed")}intersect(e,r,i,s){var o;this._sortedDrapeSourceRenderersDirty&&this._updateSortedDrapeSourceRenderers();let a=0;for(const{renderer:n}of this._sortedRenderers)a=((o=n.intersect)==null?void 0:o.call(n,e,r,i,s,a))??a}_updateSortedDrapeSourceRenderers(){if(this._sortedRenderers.clear(),this._renderers.size===0)return;const e=this.view.map.allLayers,r=e.length;this._renderers.forEach((i,s)=>{const a=e.indexOf(s.layer),o=a>=0,n=s.renderGroup??(o?Ir.MapLayer:Ir.ViewLayer),c=r*n+(o?a:0);this._sortedRenderers.push(new Zc(s,i,c))}),this._sortedRenderers.sort((i,s)=>i.index-s.index)}_setViewParameters(e,r){const i=this._camera;i.viewport=[0,0,r.resolution,r.resolution],To(i.projectionMatrix,0,e[2]-e[0],0,e[3]-e[1],i.near,i.far),Ro(i.viewMatrix,[-e[0],-e[1],0])}_updateHasWater(){const e=Wt(this._renderers,r=>r.hasWater);e!==this._hasWater&&(this._hasWater=e,this.events.emit("has-water",e))}_ensureDebugPatternResources(e,r){if(Q(this._passParameters.color,r[0],r[1],r[2]),this._passParameters.texture)return;const i=new Uint8Array(e*e*4);let s=0;for(let n=0;n<e;n++)for(let c=0;c<e;c++){const l=Math.floor(c/10),d=Math.floor(n/10);l<2||d<2||10*l>e-20||10*d>e-20?(i[s++]=255,i[s++]=255,i[s++]=255,i[s++]=255):(i[s++]=255,i[s++]=255,i[s++]=255,i[s++]=1&l&&1&d?1&c^1&n?0:255:1&l^1&d?0:128)}const a=new Ni(e);a.samplingMode=Hn.NEAREST,this._passParameters.texture=new Xt(this._rctx,a,i);const o=new Ha;o.hasAlpha=!0,this._debugTextureTechnique=this._shaderTechniques.acquire(Va,o)}get test(){return{drapedRenderers:Array.from(this._renderers.values()),sortedDrapeSources:Array.from(this._sortedRenderers).map(({drapeSource:e})=>e),getDrapeSourceRenderer:e=>this._renderers.get(e)}}};m([b()],Te.prototype,"hasHighlights",void 0),m([b()],Te.prototype,"_sortedDrapeSourceRenderersDirty",void 0),m([b()],Te.prototype,"_shaderTechniques",void 0),m([b({constructOnly:!0})],Te.prototype,"view",void 0),m([b()],Te.prototype,"worldToPCSRatio",void 0),m([b()],Te.prototype,"spatialReference",void 0),m([b({type:Boolean,readOnly:!0})],Te.prototype,"updating",null),m([b()],Te.prototype,"isEmpty",null),m([b({readOnly:!0})],Te.prototype,"rendersOccludedDraped",null),Te=m([tr("esri.views.3d.terrain.OverlayRenderer")],Te);class Zc{constructor(e,r,i){this.drapeSource=e,this.renderer=r,this.index=i}}const Qc=[[1,.5,.5],[.5,.5,1]],Cu=-2,Qs=Re.OccludeAndTransparent;var Si;(function(t){function e(o,n){const c=o[n],l=o[n+1],d=o[n+2];return Math.sqrt(c*c+l*l+d*d)}function r(o,n){const c=o[n],l=o[n+1],d=o[n+2],h=1/Math.sqrt(c*c+l*l+d*d);o[n]*=h,o[n+1]*=h,o[n+2]*=h}function i(o,n,c){o[n]*=c,o[n+1]*=c,o[n+2]*=c}function s(o,n,c,l,d,h=n){(d=d||o)[h]=o[n]+c[l],d[h+1]=o[n+1]+c[l+1],d[h+2]=o[n+2]+c[l+2]}function a(o,n,c,l,d,h=n){(d=d||o)[h]=o[n]-c[l],d[h+1]=o[n+1]-c[l+1],d[h+2]=o[n+2]-c[l+2]}t.length=e,t.normalize=r,t.scale=i,t.add=s,t.subtract=a})(Si||(Si={}));const _t=Si,ci=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],Jc=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],Yc=[0,0,1,0,1,1,0,1],Xc=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],ka=new Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)ka[6*t+e]=t;const Xe=new Array(36);for(let t=0;t<6;t++)Xe[6*t]=0,Xe[6*t+1]=1,Xe[6*t+2]=2,Xe[6*t+3]=2,Xe[6*t+4]=3,Xe[6*t+5]=0;function Su(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(24);for(let i=0;i<8;i++)r[3*i]=ci[i][0]*e[0],r[3*i+1]=ci[i][1]*e[1],r[3*i+2]=ci[i][2]*e[2];return new we(t,[[v.POSITION,new j(r,Xc,3,!0)],[v.NORMAL,new j(Jc,ka,3)],[v.UV0,new j(Yc,Xe,2)]])}const di=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],Kc=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],ed=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],td=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function Tu(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(18);for(let i=0;i<6;i++)r[3*i]=di[i][0]*e[0],r[3*i+1]=di[i][1]*e[1],r[3*i+2]=di[i][2]*e[2];return new we(t,[[v.POSITION,new j(r,ed,3,!0)],[v.NORMAL,new j(Kc,td,3)]])}const Sr=J(-.5,0,-.5),Tr=J(.5,0,-.5),Rr=J(0,0,.5),Or=J(0,.5,0),vt=Oe(),yt=Oe(),$t=Oe(),It=Oe(),Pt=Oe();ae(vt,Sr,Or),ae(yt,Sr,Tr),Le($t,vt,yt),re($t,$t),ae(vt,Tr,Or),ae(yt,Tr,Rr),Le(It,vt,yt),re(It,It),ae(vt,Rr,Or),ae(yt,Rr,Sr),Le(Pt,vt,yt),re(Pt,Pt);const hi=[Sr,Tr,Rr,Or],rd=[0,-1,0,$t[0],$t[1],$t[2],It[0],It[1],It[2],Pt[0],Pt[1],Pt[2]],id=[0,1,2,3,1,0,3,2,1,3,0,2],sd=[0,0,0,1,1,1,2,2,2,3,3,3];function Ru(t,e){Array.isArray(e)||(e=[e,e,e]);const r=new Array(12);for(let i=0;i<4;i++)r[3*i]=hi[i][0]*e[0],r[3*i+1]=hi[i][1]*e[1],r[3*i+2]=hi[i][2]*e[2];return new we(t,[[v.POSITION,new j(r,id,3,!0)],[v.NORMAL,new j(rd,sd,3)]])}function Ou(t,e,r,i,s={uv:!0}){const a=-Math.PI,o=2*Math.PI,n=-Math.PI/2,c=Math.PI,l=Math.max(3,Math.floor(r)),d=Math.max(2,Math.floor(i)),h=(l+1)*(d+1),u=De(3*h),p=De(3*h),f=De(2*h),y=[];let x=0;for(let _=0;_<=d;_++){const O=[],S=_/d,A=n+S*c,g=Math.cos(A);for(let U=0;U<=l;U++){const V=U/l,D=a+V*o,ce=Math.cos(D)*g,N=Math.sin(A),Fe=-Math.sin(D)*g;u[3*x]=ce*e,u[3*x+1]=N*e,u[3*x+2]=Fe*e,p[3*x]=ce,p[3*x+1]=N,p[3*x+2]=Fe,f[2*x]=V,f[2*x+1]=S,O.push(x),++x}y.push(O)}const R=new Array;for(let _=0;_<d;_++)for(let O=0;O<l;O++){const S=y[_][O],A=y[_][O+1],g=y[_+1][O+1],U=y[_+1][O];_===0?(R.push(S),R.push(g),R.push(U)):_===d-1?(R.push(S),R.push(A),R.push(g)):(R.push(S),R.push(A),R.push(g),R.push(g),R.push(U),R.push(S))}const C=[[v.POSITION,new j(u,R,3,!0)],[v.NORMAL,new j(p,R,3,!0)]];return s.uv&&C.push([v.UV0,new j(f,R,2,!0)]),s.offset&&(C[0][0]=v.OFFSET,C.push([v.POSITION,new j(Float64Array.from(s.offset),va(R.length),3,!0)])),new we(t,C)}function bu(t,e,r,i){const s=ad(e,r,i);return new we(t,s)}function ad(t,e,r){const i=t;let s,a;if(r)s=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],a=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const l=i*(1+Math.sqrt(5))/2;s=[-i,l,0,i,l,0,-i,-l,0,i,-l,0,0,-i,l,0,i,l,0,-i,-l,0,i,-l,l,0,-i,l,0,i,-l,0,-i,-l,0,i],a=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let l=0;l<s.length;l+=3)_t.scale(s,l,t/_t.length(s,l));let o={};function n(l,d){l>d&&([l,d]=[d,l]);const h=l.toString()+"."+d.toString();if(o[h])return o[h];let u=s.length;return s.length+=3,_t.add(s,3*l,s,3*d,s,u),_t.scale(s,u,t/_t.length(s,u)),u/=3,o[h]=u,u}for(let l=0;l<e;l++){const d=a.length,h=new Array(4*d);for(let u=0;u<d;u+=3){const p=a[u],f=a[u+1],y=a[u+2],x=n(p,f),R=n(f,y),C=n(y,p),_=4*u;h[_]=p,h[_+1]=x,h[_+2]=C,h[_+3]=f,h[_+4]=R,h[_+5]=x,h[_+6]=y,h[_+7]=C,h[_+8]=R,h[_+9]=x,h[_+10]=R,h[_+11]=C}a=h,o={}}const c=ns(s);for(let l=0;l<c.length;l+=3)_t.normalize(c,l);return[[v.POSITION,new j(ns(s),a,3,!0)],[v.NORMAL,new j(c,a,3,!0)]]}function Au(t,e,r,i,s,a,o,n,c=null){const l=r?ts(r):E(),d=e?ts(e):st(0,0,1);o??(o=k());const h=i?[255*i[0],255*i[1],255*i[2],i.length>3?255*i[3]:255]:[255,255,255,255],u=s!=null&&s.length===2?s:[1,1],p=va(1),f=[[v.POSITION,new j(l,p,3,!0)],[v.NORMAL,new j(d,p,3,!0)],[v.UV0,new j(o,p,o.length)],[v.COLOR,new j(h,p,4,!0)],[v.SIZE,new j(u,p,2)]];if(a!=null&&(a=[a[0],a[1],a[2],a[3]],f.push([v.CENTEROFFSETANDDISTANCE,new j(a,p,4)])),n){const y=[n[0],n[1],n[2],n[3]];f.push([v.FEATUREATTRIBUTE,new j(y,p,4)])}return new we(t,f,null,Nt.Point,c)}const od=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function Du(t,e=od){const r=new Array(12);for(let l=0;l<4;l++)for(let d=0;d<3;d++)r[3*l+d]=e[l][d];const i=[0,1,2,2,3,0],s=[0,0,1],a=[0,0,0,0,0,0],o=[0,0,1,0,1,1,0,1],n=[255,255,255,255],c=[[v.POSITION,new j(r,i,3,!0)],[v.NORMAL,new j(s,a,3,!0)],[v.UV0,new j(o,i,2,!0)],[v.COLOR,new j(n,a,4,!0)]];return new we(t,c)}function Mu(t,e,r,i,s,a=!0,o=!0){let n=0;const c=r,l=e;let d=J(0,n,0),h=J(0,n+l,0),u=J(0,-1,0),p=J(0,1,0);s&&(n=l,h=J(0,0,0),d=J(0,n,0),u=J(0,1,0),p=J(0,-1,0));const f=[h,d],y=[u,p],x=i+2,R=Math.sqrt(l*l+c*c);if(s)for(let g=i-1;g>=0;g--){const U=g*(2*Math.PI/i),V=J(Math.cos(U)*c,n,Math.sin(U)*c);f.push(V);const D=J(l*Math.cos(U)/R,-c/R,l*Math.sin(U)/R);y.push(D)}else for(let g=0;g<i;g++){const U=g*(2*Math.PI/i),V=J(Math.cos(U)*c,n,Math.sin(U)*c);f.push(V);const D=J(l*Math.cos(U)/R,c/R,l*Math.sin(U)/R);y.push(D)}const C=new Array,_=new Array;if(a){for(let g=3;g<f.length;g++)C.push(1),C.push(g-1),C.push(g),_.push(0),_.push(0),_.push(0);C.push(f.length-1),C.push(2),C.push(1),_.push(0),_.push(0),_.push(0)}if(o){for(let g=3;g<f.length;g++)C.push(g),C.push(g-1),C.push(0),_.push(g),_.push(g-1),_.push(1);C.push(0),C.push(2),C.push(f.length-1),_.push(1),_.push(2),_.push(y.length-1)}const O=De(3*x);for(let g=0;g<x;g++)O[3*g]=f[g][0],O[3*g+1]=f[g][1],O[3*g+2]=f[g][2];const S=De(3*x);for(let g=0;g<x;g++)S[3*g]=y[g][0],S[3*g+1]=y[g][1],S[3*g+2]=y[g][2];const A=[[v.POSITION,new j(O,C,3,!0)],[v.NORMAL,new j(S,_,3,!0)]];return new we(t,A)}function Eu(t,e,r,i,s,a,o){const n=s?gs(s):J(1,0,0),c=a?gs(a):J(0,0,0);o??(o=!0);const l=Oe();re(l,n);const d=Oe();se(d,l,Math.abs(e));const h=Oe();se(h,d,-.5),le(h,h,c);const u=J(0,1,0);Math.abs(1-Lt(l,u))<.2&&Q(u,0,0,1);const p=Oe();Le(p,l,u),re(p,p),Le(u,p,l);const f=2*i+(o?2:0),y=i+(o?2:0),x=De(3*f),R=De(3*y),C=De(2*f),_=new Array(3*i*(o?4:2)),O=new Array(3*i*(o?4:2));o&&(x[3*(f-2)]=h[0],x[3*(f-2)+1]=h[1],x[3*(f-2)+2]=h[2],C[2*(f-2)]=0,C[2*(f-2)+1]=0,x[3*(f-1)]=x[3*(f-2)]+d[0],x[3*(f-1)+1]=x[3*(f-2)+1]+d[1],x[3*(f-1)+2]=x[3*(f-2)+2]+d[2],C[2*(f-1)]=1,C[2*(f-1)+1]=1,R[3*(y-2)]=-l[0],R[3*(y-2)+1]=-l[1],R[3*(y-2)+2]=-l[2],R[3*(y-1)]=l[0],R[3*(y-1)+1]=l[1],R[3*(y-1)+2]=l[2]);const S=(D,ce,N)=>{_[D]=ce,O[D]=N};let A=0;const g=Oe(),U=Oe();for(let D=0;D<i;D++){const ce=D*(2*Math.PI/i);se(g,u,Math.sin(ce)),se(U,p,Math.cos(ce)),le(g,g,U),R[3*D]=g[0],R[3*D+1]=g[1],R[3*D+2]=g[2],se(g,g,r),le(g,g,h),x[3*D]=g[0],x[3*D+1]=g[1],x[3*D+2]=g[2],C[2*D]=D/i,C[2*D+1]=0,x[3*(D+i)]=x[3*D]+d[0],x[3*(D+i)+1]=x[3*D+1]+d[1],x[3*(D+i)+2]=x[3*D+2]+d[2],C[2*(D+i)]=D/i,C[2*D+1]=1;const N=(D+1)%i;S(A++,D,D),S(A++,D+i,D),S(A++,N,N),S(A++,N,N),S(A++,D+i,D),S(A++,N+i,N)}if(o){for(let D=0;D<i;D++){const ce=(D+1)%i;S(A++,f-2,y-2),S(A++,D,y-2),S(A++,ce,y-2)}for(let D=0;D<i;D++){const ce=(D+1)%i;S(A++,D+i,y-1),S(A++,f-1,y-1),S(A++,ce+i,y-1)}}const V=[[v.POSITION,new j(x,_,3,!0)],[v.NORMAL,new j(R,O,3,!0)],[v.UV0,new j(C,_,2,!0)]];return new we(t,V)}function $u(t,e,r,i,s,a){i=i||10,s=s==null||s,pe(e.length>1);const o=[[0,0,0]],n=[],c=[];for(let l=0;l<i;l++){n.push([0,-l-1,-(l+1)%i-1]);const d=l/i*2*Math.PI;c.push([Math.cos(d)*r,Math.sin(d)*r])}return nd(t,c,e,o,n,s,a)}function nd(t,e,r,i,s,a,o=J(0,0,0)){const n=e.length,c=De(r.length*n*3+(6*i.length||0)),l=De(r.length*n*3+(i?6:0)),d=new Array,h=new Array;let u=0,p=0;const f=E(),y=E(),x=E(),R=E(),C=E(),_=E(),O=E(),S=E(),A=E(),g=E(),U=E(),V=E(),D=E(),ce=rr();Q(A,0,1,0),ae(y,r[1],r[0]),re(y,y),a?(le(S,r[0],o),re(x,S)):Q(x,0,0,1),Js(y,x,A,A,C,x,Ys),X(R,x),X(V,C);for(let $=0;$<i.length;$++)se(_,C,i[$][0]),se(S,x,i[$][2]),le(_,_,S),le(_,_,r[0]),c[u++]=_[0],c[u++]=_[1],c[u++]=_[2];l[p++]=-y[0],l[p++]=-y[1],l[p++]=-y[2];for(let $=0;$<s.length;$++)d.push(s[$][0]>0?s[$][0]:-s[$][0]-1+i.length),d.push(s[$][1]>0?s[$][1]:-s[$][1]-1+i.length),d.push(s[$][2]>0?s[$][2]:-s[$][2]-1+i.length),h.push(0),h.push(0),h.push(0);let N=i.length;const Fe=i.length-1;for(let $=0;$<r.length;$++){let B=!1;$>0&&(X(f,y),$<r.length-1?(ae(y,r[$+1],r[$]),re(y,y)):B=!0,le(g,f,y),re(g,g),le(U,r[$-1],R),Oo(r[$],g,ce),bo(ce,Ao(U,f),S)?(ae(S,S,r[$]),re(x,S),Le(C,g,x),re(C,C)):Js(g,R,V,A,C,x,Ys),X(R,x),X(V,C)),a&&(le(S,r[$],o),re(D,S));for(let K=0;K<n;K++)if(se(_,C,e[K][0]),se(S,x,e[K][1]),le(_,_,S),re(O,_),l[p++]=O[0],l[p++]=O[1],l[p++]=O[2],le(_,_,r[$]),c[u++]=_[0],c[u++]=_[1],c[u++]=_[2],!B){const ge=(K+1)%n;d.push(N+K),d.push(N+n+K),d.push(N+ge),d.push(N+ge),d.push(N+n+K),d.push(N+n+ge);for(let je=0;je<6;je++){const lt=d.length-6;h.push(d[lt+je]-Fe)}}N+=n}const jt=r[r.length-1];for(let $=0;$<i.length;$++)se(_,C,i[$][0]),se(S,x,i[$][1]),le(_,_,S),le(_,_,jt),c[u++]=_[0],c[u++]=_[1],c[u++]=_[2];const Ne=p/3;l[p++]=y[0],l[p++]=y[1],l[p++]=y[2];const nt=N-n;for(let $=0;$<s.length;$++)d.push(s[$][0]>=0?N+s[$][0]:-s[$][0]-1+nt),d.push(s[$][2]>=0?N+s[$][2]:-s[$][2]-1+nt),d.push(s[$][1]>=0?N+s[$][1]:-s[$][1]-1+nt),h.push(Ne),h.push(Ne),h.push(Ne);const sr=[[v.POSITION,new j(c,d,3,!0)],[v.NORMAL,new j(l,h,3,!0)]];return new we(t,sr)}function Iu(t,e,r,i){pe(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),pe(e[0].length===3,"createPolylineGeometry(): malformed vertex"),pe(r==null||r.length===e.length,"createPolylineGeometry: need same number of points and normals"),pe(r==null||r[0].length===3,"createPolylineGeometry(): malformed normal");const s=Kn(3*e.length),a=new Array(2*(e.length-1));let o=0,n=0;for(let l=0;l<e.length;l++){for(let d=0;d<3;d++)s[o++]=e[l][d];l>0&&(a[n++]=l-1,a[n++]=l)}const c=[[v.POSITION,new j(s,a,3,!0)]];if(r){const l=De(3*r.length);let d=0;for(let h=0;h<e.length;h++)for(let u=0;u<3;u++)l[d++]=r[h][u];c.push([v.NORMAL,new j(l,a,3,!0)])}return i&&c.push([v.COLOR,new j(i,el(i.length/4),4)]),new we(t,c,null,Nt.Line)}function Pu(t,e,r,i,s,a=0){const o=new Array(18),n=[[-r,a,s/2],[i,a,s/2],[0,e+a,s/2],[-r,a,-s/2],[i,a,-s/2],[0,e+a,-s/2]],c=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let l=0;l<6;l++)o[3*l]=n[l][0],o[3*l+1]=n[l][1],o[3*l+2]=n[l][2];return new we(t,[[v.POSITION,new j(o,c,3,!0)]])}function Lu(t,e){const r=t.getMutableAttribute(v.POSITION).data;for(let i=0;i<r.length;i+=3){const s=r[i],a=r[i+1],o=r[i+2];Q(wt,s,a,o),ye(wt,wt,e),r[i]=wt[0],r[i+1]=wt[1],r[i+2]=wt[2]}}function Fu(t,e=t){const r=t.attributes,i=r.get(v.POSITION).data,s=r.get(v.NORMAL).data;if(s){const a=e.getMutableAttribute(v.NORMAL).data;for(let o=0;o<s.length;o+=3){const n=s[o+1];a[o+1]=-s[o+2],a[o+2]=n}}if(i){const a=e.getMutableAttribute(v.POSITION).data;for(let o=0;o<i.length;o+=3){const n=i[o+1];a[o+1]=-i[o+2],a[o+2]=n}}}function ui(t,e,r,i,s){return!(Math.abs(Lt(e,t))>s)&&(Le(r,t,e),re(r,r),Le(i,r,t),re(i,i),!0)}function Js(t,e,r,i,s,a,o){return ui(t,e,s,a,o)||ui(t,r,s,a,o)||ui(t,i,s,a,o)}const Ys=.99619469809,wt=E();let Nu=class{constructor(e,r={}){this.geometry=e,this.screenToWorldRatio=1,this._transformation=W(),this._shaderTransformation=null,this._boundingSphere=null,this.id=bi(),this.layerUid=r.layerUid,this.graphicUid=r.graphicUid,this.castShadow=r.castShadow??!1,r.objectShaderTransformation!=null&&this.objectShaderTransformationChanged(r.objectShaderTransformation)}get transformation(){return this._transformation}set transformation(e){it(this._transformation,e),this._boundingSphere=null}get boundingInfo(){return this.geometry.boundingInfo}objectShaderTransformationChanged(e){e==null?this._shaderTransformation=null:(this._shaderTransformation??(this._shaderTransformation=W()),Be(this._shaderTransformation,e,this.geometry.transformation)),this._boundingSphere=null}get boundingSphere(){return this.boundingInfo?(this._boundingSphere==null&&(this._boundingSphere??(this._boundingSphere=Ks()),ye(br(this._boundingSphere),this.boundingInfo.center,this.shaderTransformation),this._boundingSphere[3]=this.boundingInfo.radius*Xs(this.shaderTransformation)),this._boundingSphere):Do}get material(){return this.geometry.material}get type(){return this.geometry.type}get shaderTransformation(){return this._shaderTransformation??this.transformation}get attributes(){return this.geometry.attributes}get highlights(){return this.geometry.highlights}get occludees(){return this.geometry.occludees}get visible(){return this.geometry.visible}set visible(e){this.geometry.visible=e}};function zu(t,e,r,i,s,a,o,n,c,l,d){const h=md[d.mode];let u,p,f=0;if(mi(t,e,r,i,c.spatialReference,s,n))return h.requiresAlignment(d)?(f=h.applyElevationAlignmentBuffer(i,s,a,o,n,c,l,d),u=a,p=o):(u=i,p=s),mi(u,c.spatialReference,p,a,l.spatialReference,o,n)?f:void 0}function qa(t,e,r,i,s){const a=(kn(t)?t.z:qn(t)?t.array[t.offset+2]:t[2])||0;switch(r.mode){case"on-the-ground":{const o=dr(e,t,"ground")??0;return s.verticalDistanceToGround=0,s.sampledElevation=o,void(s.z=o)}case"relative-to-ground":{const o=dr(e,t,"ground")??0,n=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=n,s.sampledElevation=o,void(s.z=n+o)}case"relative-to-scene":{const o=dr(e,t,"scene")??0,n=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=n,s.sampledElevation=o,void(s.z=n+o)}case"absolute-height":{const o=r.geometryZWithOffset(a,i),n=dr(e,t,"ground")??0;return s.verticalDistanceToGround=o-n,s.sampledElevation=n,void(s.z=o)}default:return void(s.z=0)}}function Vu(t,e,r,i){return qa(t,e,r,i,At),At.z}function Uu(t,e,r){return e==null||r==null?t.definedChanged:e==="on-the-ground"&&r==="on-the-ground"?t.staysOnTheGround:e===r||e!=="on-the-ground"&&r!=="on-the-ground"?Ti.UPDATE:t.onTheGroundChanged}function Hu(t){return t==="relative-to-ground"||t==="relative-to-scene"}function Gu(t){return t!=="absolute-height"}function Wu(t,e,r,i,s){qa(e,r,s,i,At),ld(t,At.verticalDistanceToGround);const a=At.sampledElevation,o=it(gd,t.transformation);return vr[0]=e.x,vr[1]=e.y,vr[2]=At.z,tl(e.spatialReference,vr,o,i.spatialReference)?t.transformation=o:console.warn("Could not locate symbol object properly, it might be misplaced"),a}function ld(t,e){for(let r=0;r<t.geometries.length;++r){const i=t.geometries[r].getMutableAttribute(v.CENTEROFFSETANDDISTANCE);i&&i.data[3]!==e&&(i.data[3]=e,t.geometryVertexAttributeUpdated(t.geometries[r],v.CENTEROFFSETANDDISTANCE))}}function cd(t,e,r,i,s,a){let o=0;const n=a.spatialReference;e*=3,i*=3;for(let c=0;c<s;++c){const l=t[e],d=t[e+1],h=t[e+2],u=a.getElevation(l,d,h,n,"ground")??0;o+=u,r[i]=l,r[i+1]=d,r[i+2]=u,e+=3,i+=3}return o/s}function dd(t,e,r,i,s,a,o,n){let c=0;const l=n.calculateOffsetRenderUnits(o),d=n.featureExpressionInfoContext,h=a.spatialReference;e*=3,i*=3;for(let u=0;u<s;++u){const p=t[e],f=t[e+1],y=t[e+2],x=a.getElevation(p,f,y,h,"ground")??0;c+=x,r[i]=p,r[i+1]=f,r[i+2]=d==null?y+x+l:x+l,e+=3,i+=3}return c/s}function hd(t,e,r,i,s,a,o,n){let c=0;const l=n.calculateOffsetRenderUnits(o),d=n.featureExpressionInfoContext,h=a.spatialReference;e*=3,i*=3;for(let u=0;u<s;++u){const p=t[e],f=t[e+1],y=t[e+2],x=a.getElevation(p,f,y,h,"scene")??0;c+=x,r[i]=p,r[i+1]=f,r[i+2]=d==null?y+x+l:x+l,e+=3,i+=3}return c/s}function ud(t){const e=t.meterUnitOffset,r=t.featureExpressionInfoContext;return e!==0||r!=null}function pd(t,e,r,i,s,a,o,n){const c=n.calculateOffsetRenderUnits(o),l=n.featureExpressionInfoContext;e*=3,i*=3;for(let d=0;d<s;++d){const h=t[e],u=t[e+1],p=t[e+2];r[i]=h,r[i+1]=u,r[i+2]=l==null?p+c:c,e+=3,i+=3}return 0}class fd{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}}var Ti;(function(t){t[t.NONE=0]="NONE",t[t.UPDATE=1]="UPDATE",t[t.RECREATE=2]="RECREATE"})(Ti||(Ti={}));const md={"absolute-height":{applyElevationAlignmentBuffer:pd,requiresAlignment:ud},"on-the-ground":{applyElevationAlignmentBuffer:cd,requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:dd,requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:hd,requiresAlignment:()=>!0}},gd=W(),At=new fd,vr=E(),_d=()=>zr.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function vd(t){return{cachedResult:t.cachedResult,arcade:t.arcade?{func:t.arcade.func,context:t.arcade.modules.arcadeUtils.createExecContext(null,{sr:t.arcade.context.spatialReference}),modules:t.arcade.modules}:null}}function Bu(t){const e=t==null?void 0:t.expression;if(typeof e=="string"){const r=Qa(e);if(r!=null)return{cachedResult:r}}return null}async function ku(t,e,r,i){const s=t==null?void 0:t.expression;if(typeof s!="string")return null;const a=Qa(s);if(a!=null)return{cachedResult:a};const o=await Mo();Eo(r);const n=o.arcadeUtils,c=n.createSyntaxTree(s);return n.dependsOnView(c)?(i!=null&&i.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:n.createFunction(c),context:n.createExecContext(null,{sr:e}),modules:o}}}function yd(t,e,r){return t.arcadeUtils.createFeature(e.attributes,e.geometry,r)}function wd(t,e){if(t!=null&&!Za(t)){if(!e||!t.arcade)return void _d().errorOncePerTick("Arcade support required but not provided");const r=e;r._geometry&&(r._geometry=rl(r._geometry)),t.arcade.modules.arcadeUtils.updateExecContext(t.arcade.context,e)}}function xd(t){if(t!=null){if(Za(t))return t.cachedResult;const e=t.arcade;let r=e==null?void 0:e.modules.arcadeUtils.executeFunction(e.func,e.context);return typeof r!="number"&&(t.cachedResult=0,r=0),r}return 0}function qu(t,e=!1){let r=t==null?void 0:t.featureExpressionInfo;const i=r==null?void 0:r.expression;return e||i==="0"||(r=null),r??null}const Zu={cachedResult:0};function Za(t){return t.cachedResult!=null}function Qa(t){return t==="0"?0:null}class Ja{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(e){this._unit=e,this._metersPerElevationInfoUnit=$o(e)}get requiresSampledElevationInfo(){return this.mode!=="absolute-height"}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(e){this._meterUnitOffset=e,this._renderUnitOffset=0}set offsetElevationInfoUnits(e){this._meterUnitOffset=e*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(e){this._renderUnitOffset+=e}geometryZWithOffset(e,r){const i=this.calculateOffsetRenderUnits(r);return this.featureExpressionInfoContext!=null?i:e+i}calculateOffsetRenderUnits(e){let r=this._meterUnitOffset;const i=this.featureExpressionInfoContext;return i!=null&&(r+=xd(i)*this._metersPerElevationInfoUnit),r/e.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=Io(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=e.offset??0}updateFeatureExpressionInfoContext(e,r,i){if(e==null)return void(this._featureExpressionInfoContext=null);const s=e==null?void 0:e.arcade;s&&r!=null&&i!=null?(this._featureExpressionInfoContext=vd(e),wd(this._featureExpressionInfoContext,yd(s.modules,r,i))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const r=new Ja;return e!=null&&r.setFromElevationInfo(e),r}}export{I as $,Vh as A,Uh as B,Kt as C,Au as D,Pr as E,Oa as F,xe as G,lc as H,Ie as I,Jh as J,wi as K,Fr as L,xa as M,Dl as N,il as O,oc as P,Ga as Q,fd as R,kc as S,Fu as T,Tu as U,Ru as V,Su as W,bu as X,ld as Y,wd as Z,vc as _,nl as a,Zu as a0,Ti as a1,Wu as a2,Uu as a3,Hu as a4,yd as a5,Gu as a6,Ra as a7,ot as a8,at as a9,Vc as aA,Pc as aB,Qs as aC,ws as aD,nh as aE,Rs as aF,Ah as aG,Ol as aH,We as aI,gh as aJ,vh as aK,wh as aL,Ci as aM,Us as aN,Sc as aO,tu as aP,$c as aQ,Cr as aR,xi as aS,Va as aT,Ha as aU,Ul as aV,Gh as aW,zh as aX,El as aY,jl as aZ,Dc as a_,Vl as aa,ac as ab,Qt as ac,$a as ad,Hh as ae,ee as af,Ic as ag,Js as ah,Ch as ai,Rl as aj,fl as ak,Tl as al,Lr as am,wc as an,G as ao,rt as ap,ad as aq,Sh as ar,z as as,Te as at,vi as au,xs as av,bt as aw,Dh as ax,Y as ay,ys as az,_i as b,Ir as c,qu as d,qt as e,ku as f,Iu as g,qa as h,Du as i,be as j,Bu as k,Vu as l,Nu as m,er as n,Ja as o,sc as p,Lu as q,ll as r,Ou as s,Cu as t,zu as u,Eu as v,Pu as w,$u as x,Mu as y,nd as z};
